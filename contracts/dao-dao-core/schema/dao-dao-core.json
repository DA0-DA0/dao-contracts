{
  "contract_name": "dao-dao-core",
  "contract_version": "2.5.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "automatically_add_cw20s",
      "automatically_add_cw721s",
      "description",
      "name",
      "proposal_modules_instantiate_info",
      "voting_module_instantiate_info"
    ],
    "properties": {
      "admin": {
        "description": "Optional Admin with the ability to execute DAO messages directly. Useful for building SubDAOs controlled by a parent DAO. If no admin is specified the contract is set as its own admin so that the admin may be updated later by governance.",
        "type": [
          "string",
          "null"
        ]
      },
      "automatically_add_cw20s": {
        "description": "If true the contract will automatically add received cw20 tokens to its treasury.",
        "type": "boolean"
      },
      "automatically_add_cw721s": {
        "description": "If true the contract will automatically add received cw721 tokens to its treasury.",
        "type": "boolean"
      },
      "dao_uri": {
        "description": "Implements the DAO Star standard: <https://daostar.one/EIP>",
        "type": [
          "string",
          "null"
        ]
      },
      "description": {
        "description": "A description of the core contract.",
        "type": "string"
      },
      "image_url": {
        "description": "An image URL to describe the core module contract.",
        "type": [
          "string",
          "null"
        ]
      },
      "initial_items": {
        "description": "The items to instantiate this DAO with. Items are arbitrary key-value pairs whose contents are controlled by governance.\n\nIt is an error to provide two items with the same key.",
        "type": [
          "array",
          "null"
        ],
        "items": {
          "$ref": "#/definitions/InitialItem"
        }
      },
      "name": {
        "description": "The name of the core contract.",
        "type": "string"
      },
      "proposal_modules_instantiate_info": {
        "description": "Instantiate information for the core contract's proposal modules. NOTE: the pre-propose-base package depends on it being the case that the core module instantiates its proposal module.",
        "type": "array",
        "items": {
          "$ref": "#/definitions/ModuleInstantiateInfo"
        }
      },
      "voting_module_instantiate_info": {
        "description": "Instantiate information for the core contract's voting power module.",
        "allOf": [
          {
            "$ref": "#/definitions/ModuleInstantiateInfo"
          }
        ]
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Admin": {
        "description": "Information about the CosmWasm level admin of a contract. Used in conjunction with `ModuleInstantiateInfo` to instantiate modules.",
        "oneOf": [
          {
            "description": "Set the admin to a specified address.",
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "object",
                "required": [
                  "addr"
                ],
                "properties": {
                  "addr": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sets the admin as the core module address.",
            "type": "object",
            "required": [
              "core_module"
            ],
            "properties": {
              "core_module": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "InitialItem": {
        "description": "Information about an item to be stored in the items list.",
        "type": "object",
        "required": [
          "key",
          "value"
        ],
        "properties": {
          "key": {
            "description": "The name of the item.",
            "type": "string"
          },
          "value": {
            "description": "The value the item will have at instantiation time.",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "ModuleInstantiateInfo": {
        "description": "Information needed to instantiate a module.",
        "type": "object",
        "required": [
          "code_id",
          "funds",
          "label",
          "msg"
        ],
        "properties": {
          "admin": {
            "description": "CosmWasm level admin of the instantiated contract. See: <https://docs.cosmwasm.com/docs/1.0/smart-contracts/migration>",
            "anyOf": [
              {
                "$ref": "#/definitions/Admin"
              },
              {
                "type": "null"
              }
            ]
          },
          "code_id": {
            "description": "Code ID of the contract to be instantiated.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "funds": {
            "description": "Funds to be sent to the instantiated contract.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Coin"
            }
          },
          "label": {
            "description": "Label for the instantiated contract.",
            "type": "string"
          },
          "msg": {
            "description": "Instantiate message to be used to create the contract.",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Callable by the Admin, if one is configured. Executes messages in order.",
        "type": "object",
        "required": [
          "execute_admin_msgs"
        ],
        "properties": {
          "execute_admin_msgs": {
            "type": "object",
            "required": [
              "msgs"
            ],
            "properties": {
              "msgs": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CosmosMsg_for_Empty"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Callable by proposal modules. The DAO will execute the messages in the hook in order.",
        "type": "object",
        "required": [
          "execute_proposal_hook"
        ],
        "properties": {
          "execute_proposal_hook": {
            "type": "object",
            "required": [
              "msgs"
            ],
            "properties": {
              "msgs": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/CosmosMsg_for_Empty"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Pauses the DAO for a set duration. When paused the DAO is unable to execute proposals",
        "type": "object",
        "required": [
          "pause"
        ],
        "properties": {
          "pause": {
            "type": "object",
            "required": [
              "duration"
            ],
            "properties": {
              "duration": {
                "$ref": "#/definitions/Duration"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Unpauses the DAO",
        "type": "object",
        "required": [
          "unpause"
        ],
        "properties": {
          "unpause": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Executed when the contract receives a cw20 token. Depending on the contract's configuration the contract will automatically add the token to its treasury.",
        "type": "object",
        "required": [
          "receive"
        ],
        "properties": {
          "receive": {
            "$ref": "#/definitions/Cw20ReceiveMsg"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Executed when the contract receives a cw721 token. Depending on the contract's configuration the contract will automatically add the token to its treasury.",
        "type": "object",
        "required": [
          "receive_nft"
        ],
        "properties": {
          "receive_nft": {
            "$ref": "#/definitions/Cw721ReceiveMsg"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Removes an item from the governance contract's item map.",
        "type": "object",
        "required": [
          "remove_item"
        ],
        "properties": {
          "remove_item": {
            "type": "object",
            "required": [
              "key"
            ],
            "properties": {
              "key": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Adds an item to the governance contract's item map. If the item already exists the existing value is overridden. If the item does not exist a new item is added.",
        "type": "object",
        "required": [
          "set_item"
        ],
        "properties": {
          "set_item": {
            "type": "object",
            "required": [
              "key",
              "value"
            ],
            "properties": {
              "key": {
                "type": "string"
              },
              "value": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Callable by the admin of the contract. If ADMIN is None the admin is set as the contract itself so that it may be updated later by vote. If ADMIN is Some a new admin is proposed and that new admin may become the admin by executing the `AcceptAdminNomination` message.\n\nIf there is already a pending admin nomination the `WithdrawAdminNomination` message must be executed before a new admin may be nominated.",
        "type": "object",
        "required": [
          "nominate_admin"
        ],
        "properties": {
          "nominate_admin": {
            "type": "object",
            "properties": {
              "admin": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Callable by a nominated admin. Admins are nominated via the `NominateAdmin` message. Accepting a nomination will make the nominated address the new admin.\n\nRequiring that the new admin accepts the nomination before becoming the admin protects against a typo causing the admin to change to an invalid address.",
        "type": "object",
        "required": [
          "accept_admin_nomination"
        ],
        "properties": {
          "accept_admin_nomination": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Callable by the current admin. Withdraws the current admin nomination.",
        "type": "object",
        "required": [
          "withdraw_admin_nomination"
        ],
        "properties": {
          "withdraw_admin_nomination": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Callable by the core contract. Replaces the current governance contract config with the provided config.",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "required": [
              "config"
            ],
            "properties": {
              "config": {
                "$ref": "#/definitions/Config"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Updates the list of cw20 tokens this contract has registered.",
        "type": "object",
        "required": [
          "update_cw20_list"
        ],
        "properties": {
          "update_cw20_list": {
            "type": "object",
            "required": [
              "to_add",
              "to_remove"
            ],
            "properties": {
              "to_add": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "to_remove": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Updates the list of cw721 tokens this contract has registered.",
        "type": "object",
        "required": [
          "update_cw721_list"
        ],
        "properties": {
          "update_cw721_list": {
            "type": "object",
            "required": [
              "to_add",
              "to_remove"
            ],
            "properties": {
              "to_add": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "to_remove": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Updates the governance contract's governance modules. Module instantiate info in `to_add` is used to create new modules and install them.",
        "type": "object",
        "required": [
          "update_proposal_modules"
        ],
        "properties": {
          "update_proposal_modules": {
            "type": "object",
            "required": [
              "to_add",
              "to_disable"
            ],
            "properties": {
              "to_add": {
                "description": "NOTE: the pre-propose-base package depends on it being the case that the core module instantiates its proposal module.",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ModuleInstantiateInfo"
                }
              },
              "to_disable": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Callable by the core contract. Replaces the current voting module with a new one instantiated by the governance contract.",
        "type": "object",
        "required": [
          "update_voting_module"
        ],
        "properties": {
          "update_voting_module": {
            "type": "object",
            "required": [
              "module"
            ],
            "properties": {
              "module": {
                "$ref": "#/definitions/ModuleInstantiateInfo"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update the core module to add/remove SubDAOs and their charters",
        "type": "object",
        "required": [
          "update_sub_daos"
        ],
        "properties": {
          "update_sub_daos": {
            "type": "object",
            "required": [
              "to_add",
              "to_remove"
            ],
            "properties": {
              "to_add": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/SubDao"
                }
              },
              "to_remove": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Admin": {
        "description": "Information about the CosmWasm level admin of a contract. Used in conjunction with `ModuleInstantiateInfo` to instantiate modules.",
        "oneOf": [
          {
            "description": "Set the admin to a specified address.",
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "object",
                "required": [
                  "addr"
                ],
                "properties": {
                  "addr": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sets the admin as the core module address.",
            "type": "object",
            "required": [
              "core_module"
            ],
            "properties": {
              "core_module": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "BankMsg": {
        "description": "The message types of the bank module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto",
        "oneOf": [
          {
            "description": "Sends native tokens from the contract to the given address.\n\nThis is translated to a [MsgSend](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto#L19-L28). `from_address` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "send"
            ],
            "properties": {
              "send": {
                "type": "object",
                "required": [
                  "amount",
                  "to_address"
                ],
                "properties": {
                  "amount": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  },
                  "to_address": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "This will burn the given coins from the contract's account. There is no Cosmos SDK message that performs this, but it can be done by calling the bank keeper. Important if a contract controls significant token supply that must be retired.",
            "type": "object",
            "required": [
              "burn"
            ],
            "properties": {
              "burn": {
                "type": "object",
                "required": [
                  "amount"
                ],
                "properties": {
                  "amount": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Config": {
        "description": "Top level config type for core module.",
        "type": "object",
        "required": [
          "automatically_add_cw20s",
          "automatically_add_cw721s",
          "description",
          "name"
        ],
        "properties": {
          "automatically_add_cw20s": {
            "description": "If true the contract will automatically add received cw20 tokens to its treasury.",
            "type": "boolean"
          },
          "automatically_add_cw721s": {
            "description": "If true the contract will automatically add received cw721 tokens to its treasury.",
            "type": "boolean"
          },
          "dao_uri": {
            "description": "The URI for the DAO as defined by the DAOstar standard <https://daostar.one/EIP>",
            "type": [
              "string",
              "null"
            ]
          },
          "description": {
            "description": "A description of the contract.",
            "type": "string"
          },
          "image_url": {
            "description": "An optional image URL for displaying alongside the contract.",
            "type": [
              "string",
              "null"
            ]
          },
          "name": {
            "description": "The name of the contract.",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "CosmosMsg_for_Empty": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "bank"
            ],
            "properties": {
              "bank": {
                "$ref": "#/definitions/BankMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "custom"
            ],
            "properties": {
              "custom": {
                "$ref": "#/definitions/Empty"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "staking"
            ],
            "properties": {
              "staking": {
                "$ref": "#/definitions/StakingMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "distribution"
            ],
            "properties": {
              "distribution": {
                "$ref": "#/definitions/DistributionMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "A Stargate message encoded the same way as a protobuf [Any](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/any.proto). This is the same structure as messages in `TxBody` from [ADR-020](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-020-protobuf-transaction-encoding.md)",
            "type": "object",
            "required": [
              "stargate"
            ],
            "properties": {
              "stargate": {
                "type": "object",
                "required": [
                  "type_url",
                  "value"
                ],
                "properties": {
                  "type_url": {
                    "type": "string"
                  },
                  "value": {
                    "$ref": "#/definitions/Binary"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "ibc"
            ],
            "properties": {
              "ibc": {
                "$ref": "#/definitions/IbcMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "wasm"
            ],
            "properties": {
              "wasm": {
                "$ref": "#/definitions/WasmMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "gov"
            ],
            "properties": {
              "gov": {
                "$ref": "#/definitions/GovMsg"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Cw20ReceiveMsg": {
        "description": "Cw20ReceiveMsg should be de/serialized under `Receive()` variant in a ExecuteMsg",
        "type": "object",
        "required": [
          "amount",
          "msg",
          "sender"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "msg": {
            "$ref": "#/definitions/Binary"
          },
          "sender": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Cw721ReceiveMsg": {
        "description": "Cw721ReceiveMsg should be de/serialized under `Receive()` variant in a ExecuteMsg",
        "type": "object",
        "required": [
          "msg",
          "sender",
          "token_id"
        ],
        "properties": {
          "msg": {
            "$ref": "#/definitions/Binary"
          },
          "sender": {
            "type": "string"
          },
          "token_id": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "DistributionMsg": {
        "description": "The message types of the distribution module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto",
        "oneOf": [
          {
            "description": "This is translated to a [MsgSetWithdrawAddress](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L29-L37). `delegator_address` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "set_withdraw_address"
            ],
            "properties": {
              "set_withdraw_address": {
                "type": "object",
                "required": [
                  "address"
                ],
                "properties": {
                  "address": {
                    "description": "The `withdraw_address`",
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "This is translated to a [[MsgWithdrawDelegatorReward](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L42-L50). `delegator_address` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "withdraw_delegator_reward"
            ],
            "properties": {
              "withdraw_delegator_reward": {
                "type": "object",
                "required": [
                  "validator"
                ],
                "properties": {
                  "validator": {
                    "description": "The `validator_address`",
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "This is translated to a [[MsgFundCommunityPool](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#LL69C1-L76C2). `depositor` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "fund_community_pool"
            ],
            "properties": {
              "fund_community_pool": {
                "type": "object",
                "required": [
                  "amount"
                ],
                "properties": {
                  "amount": {
                    "description": "The amount to spend",
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Duration": {
        "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "height"
            ],
            "properties": {
              "height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Time in seconds",
            "type": "object",
            "required": [
              "time"
            ],
            "properties": {
              "time": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Empty": {
        "description": "An empty struct that serves as a placeholder in different places, such as contracts that don't set a custom message.\n\nIt is designed to be expressable in correct JSON and JSON Schema but contains no meaningful data. Previously we used enums without cases, but those cannot represented as valid JSON Schema (https://github.com/CosmWasm/cosmwasm/issues/451)",
        "type": "object"
      },
      "GovMsg": {
        "description": "This message type allows the contract interact with the [x/gov] module in order to cast votes.\n\n[x/gov]: https://github.com/cosmos/cosmos-sdk/tree/v0.45.12/x/gov\n\n## Examples\n\nCast a simple vote:\n\n``` # use cosmwasm_std::{ #     HexBinary, #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo, #     Response, QueryResponse, # }; # type ExecuteMsg = (); use cosmwasm_std::{GovMsg, VoteOption};\n\n#[entry_point] pub fn execute( deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg, ) -> Result<Response, StdError> { // ... Ok(Response::new().add_message(GovMsg::Vote { proposal_id: 4, vote: VoteOption::Yes, })) } ```\n\nCast a weighted vote:\n\n``` # use cosmwasm_std::{ #     HexBinary, #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo, #     Response, QueryResponse, # }; # type ExecuteMsg = (); # #[cfg(feature = \"cosmwasm_1_2\")] use cosmwasm_std::{Decimal, GovMsg, VoteOption, WeightedVoteOption};\n\n# #[cfg(feature = \"cosmwasm_1_2\")] #[entry_point] pub fn execute( deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg, ) -> Result<Response, StdError> { // ... Ok(Response::new().add_message(GovMsg::VoteWeighted { proposal_id: 4, options: vec![ WeightedVoteOption { option: VoteOption::Yes, weight: Decimal::percent(65), }, WeightedVoteOption { option: VoteOption::Abstain, weight: Decimal::percent(35), }, ], })) } ```",
        "oneOf": [
          {
            "description": "This maps directly to [MsgVote](https://github.com/cosmos/cosmos-sdk/blob/v0.42.5/proto/cosmos/gov/v1beta1/tx.proto#L46-L56) in the Cosmos SDK with voter set to the contract address.",
            "type": "object",
            "required": [
              "vote"
            ],
            "properties": {
              "vote": {
                "type": "object",
                "required": [
                  "proposal_id",
                  "vote"
                ],
                "properties": {
                  "proposal_id": {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  },
                  "vote": {
                    "description": "The vote option.\n\nThis should be called \"option\" for consistency with Cosmos SDK. Sorry for that. See <https://github.com/CosmWasm/cosmwasm/issues/1571>.",
                    "allOf": [
                      {
                        "$ref": "#/definitions/VoteOption"
                      }
                    ]
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "This maps directly to [MsgVoteWeighted](https://github.com/cosmos/cosmos-sdk/blob/v0.45.8/proto/cosmos/gov/v1beta1/tx.proto#L66-L78) in the Cosmos SDK with voter set to the contract address.",
            "type": "object",
            "required": [
              "vote_weighted"
            ],
            "properties": {
              "vote_weighted": {
                "type": "object",
                "required": [
                  "options",
                  "proposal_id"
                ],
                "properties": {
                  "options": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/WeightedVoteOption"
                    }
                  },
                  "proposal_id": {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "IbcMsg": {
        "description": "These are messages in the IBC lifecycle. Only usable by IBC-enabled contracts (contracts that directly speak the IBC protocol via 6 entry points)",
        "oneOf": [
          {
            "description": "Sends bank tokens owned by the contract to the given address on another chain. The channel must already be established between the ibctransfer module on this chain and a matching module on the remote chain. We cannot select the port_id, this is whatever the local chain has bound the ibctransfer module to.",
            "type": "object",
            "required": [
              "transfer"
            ],
            "properties": {
              "transfer": {
                "type": "object",
                "required": [
                  "amount",
                  "channel_id",
                  "timeout",
                  "to_address"
                ],
                "properties": {
                  "amount": {
                    "description": "packet data only supports one coin https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/applications/transfer/v1/transfer.proto#L11-L20",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Coin"
                      }
                    ]
                  },
                  "channel_id": {
                    "description": "existing channel to send the tokens over",
                    "type": "string"
                  },
                  "timeout": {
                    "description": "when packet times out, measured on remote chain",
                    "allOf": [
                      {
                        "$ref": "#/definitions/IbcTimeout"
                      }
                    ]
                  },
                  "to_address": {
                    "description": "address on the remote chain to receive these tokens",
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sends an IBC packet with given data over the existing channel. Data should be encoded in a format defined by the channel version, and the module on the other side should know how to parse this.",
            "type": "object",
            "required": [
              "send_packet"
            ],
            "properties": {
              "send_packet": {
                "type": "object",
                "required": [
                  "channel_id",
                  "data",
                  "timeout"
                ],
                "properties": {
                  "channel_id": {
                    "type": "string"
                  },
                  "data": {
                    "$ref": "#/definitions/Binary"
                  },
                  "timeout": {
                    "description": "when packet times out, measured on remote chain",
                    "allOf": [
                      {
                        "$ref": "#/definitions/IbcTimeout"
                      }
                    ]
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "This will close an existing channel that is owned by this contract. Port is auto-assigned to the contract's IBC port",
            "type": "object",
            "required": [
              "close_channel"
            ],
            "properties": {
              "close_channel": {
                "type": "object",
                "required": [
                  "channel_id"
                ],
                "properties": {
                  "channel_id": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "IbcTimeout": {
        "description": "In IBC each package must set at least one type of timeout: the timestamp or the block height. Using this rather complex enum instead of two timeout fields we ensure that at least one timeout is set.",
        "type": "object",
        "properties": {
          "block": {
            "anyOf": [
              {
                "$ref": "#/definitions/IbcTimeoutBlock"
              },
              {
                "type": "null"
              }
            ]
          },
          "timestamp": {
            "anyOf": [
              {
                "$ref": "#/definitions/Timestamp"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "IbcTimeoutBlock": {
        "description": "IBCTimeoutHeight Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients. Ordering is (revision_number, timeout_height)",
        "type": "object",
        "required": [
          "height",
          "revision"
        ],
        "properties": {
          "height": {
            "description": "block height after which the packet times out. the height within the given revision",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "revision": {
            "description": "the version that the client is currently on (e.g. after resetting the chain this could increment 1 as height drops to 0)",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        }
      },
      "ModuleInstantiateInfo": {
        "description": "Information needed to instantiate a module.",
        "type": "object",
        "required": [
          "code_id",
          "funds",
          "label",
          "msg"
        ],
        "properties": {
          "admin": {
            "description": "CosmWasm level admin of the instantiated contract. See: <https://docs.cosmwasm.com/docs/1.0/smart-contracts/migration>",
            "anyOf": [
              {
                "$ref": "#/definitions/Admin"
              },
              {
                "type": "null"
              }
            ]
          },
          "code_id": {
            "description": "Code ID of the contract to be instantiated.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "funds": {
            "description": "Funds to be sent to the instantiated contract.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Coin"
            }
          },
          "label": {
            "description": "Label for the instantiated contract.",
            "type": "string"
          },
          "msg": {
            "description": "Instantiate message to be used to create the contract.",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "StakingMsg": {
        "description": "The message types of the staking module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto",
        "oneOf": [
          {
            "description": "This is translated to a [MsgDelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L81-L90). `delegator_address` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "delegate"
            ],
            "properties": {
              "delegate": {
                "type": "object",
                "required": [
                  "amount",
                  "validator"
                ],
                "properties": {
                  "amount": {
                    "$ref": "#/definitions/Coin"
                  },
                  "validator": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "This is translated to a [MsgUndelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L112-L121). `delegator_address` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "undelegate"
            ],
            "properties": {
              "undelegate": {
                "type": "object",
                "required": [
                  "amount",
                  "validator"
                ],
                "properties": {
                  "amount": {
                    "$ref": "#/definitions/Coin"
                  },
                  "validator": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "This is translated to a [MsgBeginRedelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L95-L105). `delegator_address` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "redelegate"
            ],
            "properties": {
              "redelegate": {
                "type": "object",
                "required": [
                  "amount",
                  "dst_validator",
                  "src_validator"
                ],
                "properties": {
                  "amount": {
                    "$ref": "#/definitions/Coin"
                  },
                  "dst_validator": {
                    "type": "string"
                  },
                  "src_validator": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "SubDao": {
        "type": "object",
        "required": [
          "addr"
        ],
        "properties": {
          "addr": {
            "description": "The contract address of the SubDAO",
            "type": "string"
          },
          "charter": {
            "description": "The purpose/constitution for the SubDAO",
            "type": [
              "string",
              "null"
            ]
          }
        },
        "additionalProperties": false
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      },
      "VoteOption": {
        "type": "string",
        "enum": [
          "yes",
          "no",
          "abstain",
          "no_with_veto"
        ]
      },
      "WasmMsg": {
        "description": "The message types of the wasm module.\n\nSee https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto",
        "oneOf": [
          {
            "description": "Dispatches a call to another contract at a known address (with known ABI).\n\nThis is translated to a [MsgExecuteContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L68-L78). `sender` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "execute"
            ],
            "properties": {
              "execute": {
                "type": "object",
                "required": [
                  "contract_addr",
                  "funds",
                  "msg"
                ],
                "properties": {
                  "contract_addr": {
                    "type": "string"
                  },
                  "funds": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  },
                  "msg": {
                    "description": "msg is the json-encoded ExecuteMsg struct (as raw Binary)",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      }
                    ]
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Instantiates a new contracts from previously uploaded Wasm code.\n\nThe contract address is non-predictable. But it is guaranteed that when emitting the same Instantiate message multiple times, multiple instances on different addresses will be generated. See also Instantiate2.\n\nThis is translated to a [MsgInstantiateContract](https://github.com/CosmWasm/wasmd/blob/v0.29.2/proto/cosmwasm/wasm/v1/tx.proto#L53-L71). `sender` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "instantiate"
            ],
            "properties": {
              "instantiate": {
                "type": "object",
                "required": [
                  "code_id",
                  "funds",
                  "label",
                  "msg"
                ],
                "properties": {
                  "admin": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "code_id": {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  },
                  "funds": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  },
                  "label": {
                    "description": "A human-readable label for the contract.\n\nValid values should: - not be empty - not be bigger than 128 bytes (or some chain-specific limit) - not start / end with whitespace",
                    "type": "string"
                  },
                  "msg": {
                    "description": "msg is the JSON-encoded InstantiateMsg struct (as raw Binary)",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      }
                    ]
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Instantiates a new contracts from previously uploaded Wasm code using a predictable address derivation algorithm implemented in [`cosmwasm_std::instantiate2_address`].\n\nThis is translated to a [MsgInstantiateContract2](https://github.com/CosmWasm/wasmd/blob/v0.29.2/proto/cosmwasm/wasm/v1/tx.proto#L73-L96). `sender` is automatically filled with the current contract's address. `fix_msg` is automatically set to false.",
            "type": "object",
            "required": [
              "instantiate2"
            ],
            "properties": {
              "instantiate2": {
                "type": "object",
                "required": [
                  "code_id",
                  "funds",
                  "label",
                  "msg",
                  "salt"
                ],
                "properties": {
                  "admin": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "code_id": {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  },
                  "funds": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  },
                  "label": {
                    "description": "A human-readable label for the contract.\n\nValid values should: - not be empty - not be bigger than 128 bytes (or some chain-specific limit) - not start / end with whitespace",
                    "type": "string"
                  },
                  "msg": {
                    "description": "msg is the JSON-encoded InstantiateMsg struct (as raw Binary)",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      }
                    ]
                  },
                  "salt": {
                    "$ref": "#/definitions/Binary"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Migrates a given contracts to use new wasm code. Passes a MigrateMsg to allow us to customize behavior.\n\nOnly the contract admin (as defined in wasmd), if any, is able to make this call.\n\nThis is translated to a [MsgMigrateContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L86-L96). `sender` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "migrate"
            ],
            "properties": {
              "migrate": {
                "type": "object",
                "required": [
                  "contract_addr",
                  "msg",
                  "new_code_id"
                ],
                "properties": {
                  "contract_addr": {
                    "type": "string"
                  },
                  "msg": {
                    "description": "msg is the json-encoded MigrateMsg struct that will be passed to the new code",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      }
                    ]
                  },
                  "new_code_id": {
                    "description": "the code_id of the new logic to place in the given contract",
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sets a new admin (for migrate) on the given contract. Fails if this contract is not currently admin of the target contract.",
            "type": "object",
            "required": [
              "update_admin"
            ],
            "properties": {
              "update_admin": {
                "type": "object",
                "required": [
                  "admin",
                  "contract_addr"
                ],
                "properties": {
                  "admin": {
                    "type": "string"
                  },
                  "contract_addr": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Clears the admin on the given contract, so no more migration possible. Fails if this contract is not currently admin of the target contract.",
            "type": "object",
            "required": [
              "clear_admin"
            ],
            "properties": {
              "clear_admin": {
                "type": "object",
                "required": [
                  "contract_addr"
                ],
                "properties": {
                  "contract_addr": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "WeightedVoteOption": {
        "type": "object",
        "required": [
          "option",
          "weight"
        ],
        "properties": {
          "option": {
            "$ref": "#/definitions/VoteOption"
          },
          "weight": {
            "$ref": "#/definitions/Decimal"
          }
        }
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Get's the DAO's admin. Returns `Addr`.",
        "type": "object",
        "required": [
          "admin"
        ],
        "properties": {
          "admin": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get's the currently nominated admin (if any).",
        "type": "object",
        "required": [
          "admin_nomination"
        ],
        "properties": {
          "admin_nomination": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the contract's config.",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the token balance for each cw20 registered with the contract.",
        "type": "object",
        "required": [
          "cw20_balances"
        ],
        "properties": {
          "cw20_balances": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Lists the addresses of the cw20 tokens in this contract's treasury.",
        "type": "object",
        "required": [
          "cw20_token_list"
        ],
        "properties": {
          "cw20_token_list": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Lists the addresses of the cw721 tokens in this contract's treasury.",
        "type": "object",
        "required": [
          "cw721_token_list"
        ],
        "properties": {
          "cw721_token_list": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Dumps all of the core contract's state in a single query. Useful for frontends as performance for queries is more limited by network times than compute times.",
        "type": "object",
        "required": [
          "dump_state"
        ],
        "properties": {
          "dump_state": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the address associated with an item key.",
        "type": "object",
        "required": [
          "get_item"
        ],
        "properties": {
          "get_item": {
            "type": "object",
            "required": [
              "key"
            ],
            "properties": {
              "key": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Lists all of the items associted with the contract. For example, given the items `{ \"group\": \"foo\", \"subdao\": \"bar\"}` this query would return `[(\"group\", \"foo\"), (\"subdao\", \"bar\")]`.",
        "type": "object",
        "required": [
          "list_items"
        ],
        "properties": {
          "list_items": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns contract version info",
        "type": "object",
        "required": [
          "info"
        ],
        "properties": {
          "info": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets all proposal modules associated with the contract.",
        "type": "object",
        "required": [
          "proposal_modules"
        ],
        "properties": {
          "proposal_modules": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the active proposal modules associated with the contract.",
        "type": "object",
        "required": [
          "active_proposal_modules"
        ],
        "properties": {
          "active_proposal_modules": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the number of active and total proposal modules registered with this module.",
        "type": "object",
        "required": [
          "proposal_module_count"
        ],
        "properties": {
          "proposal_module_count": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns information about if the contract is currently paused.",
        "type": "object",
        "required": [
          "pause_info"
        ],
        "properties": {
          "pause_info": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the contract's voting module.",
        "type": "object",
        "required": [
          "voting_module"
        ],
        "properties": {
          "voting_module": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns all SubDAOs with their charters in a vec. start_after is bound exclusive and asks for a string address.",
        "type": "object",
        "required": [
          "list_sub_daos"
        ],
        "properties": {
          "list_sub_daos": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Implements the DAO Star standard: <https://daostar.one/EIP>",
        "type": "object",
        "required": [
          "dao_u_r_i"
        ],
        "properties": {
          "dao_u_r_i": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the voting power for an address at a given height.",
        "type": "object",
        "required": [
          "voting_power_at_height"
        ],
        "properties": {
          "voting_power_at_height": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              },
              "height": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the total voting power at a given block height.",
        "type": "object",
        "required": [
          "total_power_at_height"
        ],
        "properties": {
          "total_power_at_height": {
            "type": "object",
            "properties": {
              "height": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "from_v1"
        ],
        "properties": {
          "from_v1": {
            "type": "object",
            "properties": {
              "dao_uri": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "params": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/MigrateParams"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "from_compatible"
        ],
        "properties": {
          "from_compatible": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Admin": {
        "description": "Information about the CosmWasm level admin of a contract. Used in conjunction with `ModuleInstantiateInfo` to instantiate modules.",
        "oneOf": [
          {
            "description": "Set the admin to a specified address.",
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "object",
                "required": [
                  "addr"
                ],
                "properties": {
                  "addr": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sets the admin as the core module address.",
            "type": "object",
            "required": [
              "core_module"
            ],
            "properties": {
              "core_module": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "MigrateParams": {
        "type": "object",
        "required": [
          "migrator_code_id",
          "params"
        ],
        "properties": {
          "migrator_code_id": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "params": {
            "$ref": "#/definitions/MigrateV1ToV2"
          }
        },
        "additionalProperties": false
      },
      "MigrateV1ToV2": {
        "type": "object",
        "required": [
          "migration_params",
          "sub_daos",
          "v1_code_ids",
          "v2_code_ids"
        ],
        "properties": {
          "migration_params": {
            "$ref": "#/definitions/MigrationModuleParams"
          },
          "sub_daos": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/SubDao"
            }
          },
          "v1_code_ids": {
            "$ref": "#/definitions/V1CodeIds"
          },
          "v2_code_ids": {
            "$ref": "#/definitions/V2CodeIds"
          }
        },
        "additionalProperties": false
      },
      "MigrationModuleParams": {
        "type": "object",
        "required": [
          "proposal_params"
        ],
        "properties": {
          "migrate_stake_cw20_manager": {
            "description": "Rather or not to migrate the stake_cw20 contract and its manager. If this is not set to true and a stake_cw20 contract is detected in the DAO's configuration the migration will be aborted.",
            "type": [
              "boolean",
              "null"
            ]
          },
          "proposal_params": {
            "type": "array",
            "items": {
              "type": "array",
              "items": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/definitions/ProposalParams"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            }
          }
        },
        "additionalProperties": false
      },
      "ModuleInstantiateInfo": {
        "description": "Information needed to instantiate a module.",
        "type": "object",
        "required": [
          "code_id",
          "funds",
          "label",
          "msg"
        ],
        "properties": {
          "admin": {
            "description": "CosmWasm level admin of the instantiated contract. See: <https://docs.cosmwasm.com/docs/1.0/smart-contracts/migration>",
            "anyOf": [
              {
                "$ref": "#/definitions/Admin"
              },
              {
                "type": "null"
              }
            ]
          },
          "code_id": {
            "description": "Code ID of the contract to be instantiated.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "funds": {
            "description": "Funds to be sent to the instantiated contract.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Coin"
            }
          },
          "label": {
            "description": "Label for the instantiated contract.",
            "type": "string"
          },
          "msg": {
            "description": "Instantiate message to be used to create the contract.",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "PreProposeInfo": {
        "oneOf": [
          {
            "description": "Anyone may create a proposal free of charge.",
            "type": "object",
            "required": [
              "anyone_may_propose"
            ],
            "properties": {
              "anyone_may_propose": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "The module specified in INFO has exclusive rights to proposal creation.",
            "type": "object",
            "required": [
              "module_may_propose"
            ],
            "properties": {
              "module_may_propose": {
                "type": "object",
                "required": [
                  "info"
                ],
                "properties": {
                  "info": {
                    "$ref": "#/definitions/ModuleInstantiateInfo"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ProposalParams": {
        "description": "The params we need to provide for migration msgs",
        "type": "object",
        "required": [
          "close_proposal_on_execution_failure",
          "pre_propose_info"
        ],
        "properties": {
          "close_proposal_on_execution_failure": {
            "type": "boolean"
          },
          "pre_propose_info": {
            "$ref": "#/definitions/PreProposeInfo"
          }
        },
        "additionalProperties": false
      },
      "SubDao": {
        "type": "object",
        "required": [
          "addr"
        ],
        "properties": {
          "addr": {
            "description": "The contract address of the SubDAO",
            "type": "string"
          },
          "charter": {
            "description": "The purpose/constitution for the SubDAO",
            "type": [
              "string",
              "null"
            ]
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "V1CodeIds": {
        "type": "object",
        "required": [
          "cw20_stake",
          "cw20_staked_balances_voting",
          "cw4_voting",
          "proposal_single"
        ],
        "properties": {
          "cw20_stake": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "cw20_staked_balances_voting": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "cw4_voting": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "proposal_single": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "V2CodeIds": {
        "type": "object",
        "required": [
          "cw20_stake",
          "cw20_staked_balances_voting",
          "cw4_voting",
          "proposal_single"
        ],
        "properties": {
          "cw20_stake": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "cw20_staked_balances_voting": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "cw4_voting": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "proposal_single": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      }
    }
  },
  "sudo": null,
  "responses": {
    "active_proposal_modules": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_ProposalModule",
      "type": "array",
      "items": {
        "$ref": "#/definitions/ProposalModule"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "ProposalModule": {
          "description": "Top level type describing a proposal module.",
          "type": "object",
          "required": [
            "address",
            "prefix",
            "status"
          ],
          "properties": {
            "address": {
              "description": "The address of the proposal module.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "prefix": {
              "description": "The URL prefix of this proposal module as derived from the module ID. Prefixes are mapped to letters, e.g. 0 is 'A', and 26 is 'AA'.",
              "type": "string"
            },
            "status": {
              "description": "The status of the proposal module, e.g. 'Enabled' or 'Disabled.'",
              "allOf": [
                {
                  "$ref": "#/definitions/ProposalModuleStatus"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "ProposalModuleStatus": {
          "description": "The status of a proposal module.",
          "type": "string",
          "enum": [
            "enabled",
            "disabled"
          ]
        }
      }
    },
    "admin": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "admin_nomination": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AdminNominationResponse",
      "description": "Returned by the `AdminNomination` query.",
      "type": "object",
      "properties": {
        "nomination": {
          "description": "The currently nominated admin or None if no nomination is pending.",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config",
      "description": "Top level config type for core module.",
      "type": "object",
      "required": [
        "automatically_add_cw20s",
        "automatically_add_cw721s",
        "description",
        "name"
      ],
      "properties": {
        "automatically_add_cw20s": {
          "description": "If true the contract will automatically add received cw20 tokens to its treasury.",
          "type": "boolean"
        },
        "automatically_add_cw721s": {
          "description": "If true the contract will automatically add received cw721 tokens to its treasury.",
          "type": "boolean"
        },
        "dao_uri": {
          "description": "The URI for the DAO as defined by the DAOstar standard <https://daostar.one/EIP>",
          "type": [
            "string",
            "null"
          ]
        },
        "description": {
          "description": "A description of the contract.",
          "type": "string"
        },
        "image_url": {
          "description": "An optional image URL for displaying alongside the contract.",
          "type": [
            "string",
            "null"
          ]
        },
        "name": {
          "description": "The name of the contract.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "cw20_balances": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Cw20BalanceResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Cw20BalanceResponse"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Cw20BalanceResponse": {
          "description": "Returned by the `Cw20Balances` query.",
          "type": "object",
          "required": [
            "addr",
            "balance"
          ],
          "properties": {
            "addr": {
              "description": "The address of the token.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "balance": {
              "description": "The contract's balance.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "cw20_token_list": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Addr",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Addr"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "cw721_token_list": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Addr",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Addr"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "dao_u_r_i": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DaoURIResponse",
      "type": "object",
      "properties": {
        "dao_uri": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "dump_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DumpStateResponse",
      "description": "Relevant state for the governance module. Returned by the `DumpState` query.",
      "type": "object",
      "required": [
        "active_proposal_module_count",
        "admin",
        "config",
        "pause_info",
        "proposal_modules",
        "total_proposal_module_count",
        "version",
        "voting_module"
      ],
      "properties": {
        "active_proposal_module_count": {
          "description": "The number of active proposal modules.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "admin": {
          "description": "Optional DAO Admin",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "config": {
          "description": "The governance contract's config.",
          "allOf": [
            {
              "$ref": "#/definitions/Config"
            }
          ]
        },
        "pause_info": {
          "$ref": "#/definitions/PauseInfoResponse"
        },
        "proposal_modules": {
          "description": "The governance modules associated with the governance contract.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ProposalModule"
          }
        },
        "total_proposal_module_count": {
          "description": "The total number of proposal modules.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "version": {
          "description": "The governance contract's version.",
          "allOf": [
            {
              "$ref": "#/definitions/ContractVersion"
            }
          ]
        },
        "voting_module": {
          "description": "The voting module associated with the governance contract.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Config": {
          "description": "Top level config type for core module.",
          "type": "object",
          "required": [
            "automatically_add_cw20s",
            "automatically_add_cw721s",
            "description",
            "name"
          ],
          "properties": {
            "automatically_add_cw20s": {
              "description": "If true the contract will automatically add received cw20 tokens to its treasury.",
              "type": "boolean"
            },
            "automatically_add_cw721s": {
              "description": "If true the contract will automatically add received cw721 tokens to its treasury.",
              "type": "boolean"
            },
            "dao_uri": {
              "description": "The URI for the DAO as defined by the DAOstar standard <https://daostar.one/EIP>",
              "type": [
                "string",
                "null"
              ]
            },
            "description": {
              "description": "A description of the contract.",
              "type": "string"
            },
            "image_url": {
              "description": "An optional image URL for displaying alongside the contract.",
              "type": [
                "string",
                "null"
              ]
            },
            "name": {
              "description": "The name of the contract.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "ContractVersion": {
          "type": "object",
          "required": [
            "contract",
            "version"
          ],
          "properties": {
            "contract": {
              "description": "contract is the crate name of the implementing contract, eg. `crate:cw20-base` we will use other prefixes for other languages, and their standard global namespacing",
              "type": "string"
            },
            "version": {
              "description": "version is any string that this implementation knows. It may be simple counter \"1\", \"2\". or semantic version on release tags \"v0.7.0\", or some custom feature flag list. the only code that needs to understand the version parsing is code that knows how to migrate from the given contract (and is tied to it's implementation somehow)",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PauseInfoResponse": {
          "description": "Information about if the contract is currently paused.",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "paused"
              ],
              "properties": {
                "paused": {
                  "type": "object",
                  "required": [
                    "expiration"
                  ],
                  "properties": {
                    "expiration": {
                      "$ref": "#/definitions/Expiration"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "unpaused"
              ],
              "properties": {
                "unpaused": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "ProposalModule": {
          "description": "Top level type describing a proposal module.",
          "type": "object",
          "required": [
            "address",
            "prefix",
            "status"
          ],
          "properties": {
            "address": {
              "description": "The address of the proposal module.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "prefix": {
              "description": "The URL prefix of this proposal module as derived from the module ID. Prefixes are mapped to letters, e.g. 0 is 'A', and 26 is 'AA'.",
              "type": "string"
            },
            "status": {
              "description": "The status of the proposal module, e.g. 'Enabled' or 'Disabled.'",
              "allOf": [
                {
                  "$ref": "#/definitions/ProposalModuleStatus"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "ProposalModuleStatus": {
          "description": "The status of a proposal module.",
          "type": "string",
          "enum": [
            "enabled",
            "disabled"
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_item": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GetItemResponse",
      "description": "Returned by the `GetItem` query.",
      "type": "object",
      "properties": {
        "item": {
          "description": "`None` if no item with the provided key was found, `Some` otherwise.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "InfoResponse",
      "type": "object",
      "required": [
        "info"
      ],
      "properties": {
        "info": {
          "$ref": "#/definitions/ContractVersion"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "ContractVersion": {
          "type": "object",
          "required": [
            "contract",
            "version"
          ],
          "properties": {
            "contract": {
              "description": "contract is the crate name of the implementing contract, eg. `crate:cw20-base` we will use other prefixes for other languages, and their standard global namespacing",
              "type": "string"
            },
            "version": {
              "description": "version is any string that this implementation knows. It may be simple counter \"1\", \"2\". or semantic version on release tags \"v0.7.0\", or some custom feature flag list. the only code that needs to understand the version parsing is code that knows how to migrate from the given contract (and is tied to it's implementation somehow)",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      }
    },
    "list_items": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Tuple_of_String_and_String",
      "type": "array",
      "items": {
        "type": "array",
        "items": [
          {
            "type": "string"
          },
          {
            "type": "string"
          }
        ],
        "maxItems": 2,
        "minItems": 2
      }
    },
    "list_sub_daos": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_SubDao",
      "type": "array",
      "items": {
        "$ref": "#/definitions/SubDao"
      },
      "definitions": {
        "SubDao": {
          "type": "object",
          "required": [
            "addr"
          ],
          "properties": {
            "addr": {
              "description": "The contract address of the SubDAO",
              "type": "string"
            },
            "charter": {
              "description": "The purpose/constitution for the SubDAO",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "additionalProperties": false
        }
      }
    },
    "pause_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PauseInfoResponse",
      "description": "Information about if the contract is currently paused.",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "paused"
          ],
          "properties": {
            "paused": {
              "type": "object",
              "required": [
                "expiration"
              ],
              "properties": {
                "expiration": {
                  "$ref": "#/definitions/Expiration"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "unpaused"
          ],
          "properties": {
            "unpaused": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "proposal_module_count": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ProposalModuleCountResponse",
      "type": "object",
      "required": [
        "active_proposal_module_count",
        "total_proposal_module_count"
      ],
      "properties": {
        "active_proposal_module_count": {
          "description": "The number of active proposal modules.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "total_proposal_module_count": {
          "description": "The total number of proposal modules.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "proposal_modules": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_ProposalModule",
      "type": "array",
      "items": {
        "$ref": "#/definitions/ProposalModule"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "ProposalModule": {
          "description": "Top level type describing a proposal module.",
          "type": "object",
          "required": [
            "address",
            "prefix",
            "status"
          ],
          "properties": {
            "address": {
              "description": "The address of the proposal module.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "prefix": {
              "description": "The URL prefix of this proposal module as derived from the module ID. Prefixes are mapped to letters, e.g. 0 is 'A', and 26 is 'AA'.",
              "type": "string"
            },
            "status": {
              "description": "The status of the proposal module, e.g. 'Enabled' or 'Disabled.'",
              "allOf": [
                {
                  "$ref": "#/definitions/ProposalModuleStatus"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "ProposalModuleStatus": {
          "description": "The status of a proposal module.",
          "type": "string",
          "enum": [
            "enabled",
            "disabled"
          ]
        }
      }
    },
    "total_power_at_height": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TotalPowerAtHeightResponse",
      "type": "object",
      "required": [
        "height",
        "power"
      ],
      "properties": {
        "height": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "power": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "voting_module": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "voting_power_at_height": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VotingPowerAtHeightResponse",
      "type": "object",
      "required": [
        "height",
        "power"
      ],
      "properties": {
        "height": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "power": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
