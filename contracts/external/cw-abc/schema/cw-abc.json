{
  "contract_name": "cw-abc",
  "contract_version": "2.4.1",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "curve_type",
      "phase_config",
      "reserve",
      "supply",
      "token_issuer_code_id"
    ],
    "properties": {
      "curve_type": {
        "description": "Curve type for this contract",
        "allOf": [
          {
            "$ref": "#/definitions/CurveType"
          }
        ]
      },
      "funding_pool_forwarding": {
        "description": "An optional address for automatically forwarding funding pool gains",
        "type": [
          "string",
          "null"
        ]
      },
      "hatcher_allowlist": {
        "description": "TODO different ways of doing this, for example DAO members? Using a whitelist contract? Merkle tree? Hatcher allowlist",
        "type": [
          "array",
          "null"
        ],
        "items": {
          "$ref": "#/definitions/HatcherAllowlistEntryMsg"
        }
      },
      "phase_config": {
        "description": "Hatch configuration information",
        "allOf": [
          {
            "$ref": "#/definitions/CommonsPhaseConfig"
          }
        ]
      },
      "reserve": {
        "description": "Reserve token information",
        "allOf": [
          {
            "$ref": "#/definitions/ReserveToken"
          }
        ]
      },
      "supply": {
        "description": "Supply token information",
        "allOf": [
          {
            "$ref": "#/definitions/SupplyToken"
          }
        ]
      },
      "token_issuer_code_id": {
        "description": "The code id of the cw-tokenfactory-issuer contract",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      }
    },
    "additionalProperties": false,
    "definitions": {
      "ClosedConfig": {
        "type": "object",
        "additionalProperties": false
      },
      "CommonsPhaseConfig": {
        "type": "object",
        "required": [
          "closed",
          "hatch",
          "open"
        ],
        "properties": {
          "closed": {
            "description": "The Closed phase where the Commons is closed to new members.",
            "allOf": [
              {
                "$ref": "#/definitions/ClosedConfig"
              }
            ]
          },
          "hatch": {
            "description": "The Hatch phase where initial contributors (Hatchers) participate in a hatch sale.",
            "allOf": [
              {
                "$ref": "#/definitions/HatchConfig"
              }
            ]
          },
          "open": {
            "description": "TODO Vest tokens after hatch phase The Vesting phase where tokens minted during the Hatch phase are locked (burning is disabled) to combat early speculation/arbitrage. pub vesting: VestingConfig, The Open phase where anyone can mint tokens by contributing the reserve token into the curve and becoming members of the Commons.",
            "allOf": [
              {
                "$ref": "#/definitions/OpenConfig"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "CurveType": {
        "oneOf": [
          {
            "description": "Constant always returns `value * 10^-scale` as spot price",
            "type": "object",
            "required": [
              "constant"
            ],
            "properties": {
              "constant": {
                "type": "object",
                "required": [
                  "scale",
                  "value"
                ],
                "properties": {
                  "scale": {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "value": {
                    "$ref": "#/definitions/Uint128"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Linear returns `slope * 10^-scale * supply` as spot price",
            "type": "object",
            "required": [
              "linear"
            ],
            "properties": {
              "linear": {
                "type": "object",
                "required": [
                  "scale",
                  "slope"
                ],
                "properties": {
                  "scale": {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "slope": {
                    "$ref": "#/definitions/Uint128"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "SquareRoot returns `slope * 10^-scale * supply^0.5` as spot price",
            "type": "object",
            "required": [
              "square_root"
            ],
            "properties": {
              "square_root": {
                "type": "object",
                "required": [
                  "scale",
                  "slope"
                ],
                "properties": {
                  "scale": {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "slope": {
                    "$ref": "#/definitions/Uint128"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "DenomUnit": {
        "description": "DenomUnit represents a struct that describes a given denomination unit of the basic token.",
        "type": "object",
        "required": [
          "aliases",
          "denom",
          "exponent"
        ],
        "properties": {
          "aliases": {
            "description": "aliases is a list of string aliases for the given denom",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "denom": {
            "description": "denom represents the string name of the given denom unit (e.g uatom).",
            "type": "string"
          },
          "exponent": {
            "description": "exponent represents power of 10 exponent that one must raise the base_denom to in order to equal the given DenomUnit's denom 1 denom = 1^exponent base_denom (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with exponent = 6, thus: 1 atom = 10^6 uatom).",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          }
        }
      },
      "HatchConfig": {
        "type": "object",
        "required": [
          "contribution_limits",
          "entry_fee",
          "initial_raise"
        ],
        "properties": {
          "contribution_limits": {
            "description": "The minimum and maximum contribution amounts (min, max) in the reserve token",
            "allOf": [
              {
                "$ref": "#/definitions/MinMax"
              }
            ]
          },
          "entry_fee": {
            "description": "The initial allocation (Î¸), percentage of the initial raise allocated to the Funding Pool",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "initial_raise": {
            "description": "The initial raise range (min, max) in the reserve token",
            "allOf": [
              {
                "$ref": "#/definitions/MinMax"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "HatcherAllowlistConfigMsg": {
        "type": "object",
        "required": [
          "config_type"
        ],
        "properties": {
          "config_type": {
            "description": "The type of the configuration",
            "allOf": [
              {
                "$ref": "#/definitions/HatcherAllowlistConfigType"
              }
            ]
          },
          "contribution_limits_override": {
            "description": "An optional override of the hatch_config's contribution limit",
            "anyOf": [
              {
                "$ref": "#/definitions/MinMax"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "HatcherAllowlistConfigType": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "d_a_o"
            ],
            "properties": {
              "d_a_o": {
                "type": "object",
                "properties": {
                  "priority": {
                    "description": "The optional priority for checking a DAO config None will append the item to the end of the priority queue (least priority)",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Uint64"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "HatcherAllowlistEntryMsg": {
        "type": "object",
        "required": [
          "addr",
          "config"
        ],
        "properties": {
          "addr": {
            "type": "string"
          },
          "config": {
            "$ref": "#/definitions/HatcherAllowlistConfigMsg"
          }
        },
        "additionalProperties": false
      },
      "MinMax": {
        "description": "Struct for minimum and maximum values",
        "type": "object",
        "required": [
          "max",
          "min"
        ],
        "properties": {
          "max": {
            "$ref": "#/definitions/Uint128"
          },
          "min": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "additionalProperties": false
      },
      "NewDenomMetadata": {
        "type": "object",
        "required": [
          "description",
          "display",
          "name",
          "symbol"
        ],
        "properties": {
          "additional_denom_units": {
            "description": "Used define additional units of the token (e.g. \"tiger\") These must have an exponent larger than 0.",
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/definitions/DenomUnit"
            }
          },
          "description": {
            "description": "The description of the token",
            "type": "string"
          },
          "display": {
            "description": "The unit commonly used in communication (e.g. \"cat\")",
            "type": "string"
          },
          "name": {
            "description": "The name of the token (e.g. \"Cat Coin\")",
            "type": "string"
          },
          "symbol": {
            "description": "The ticker symbol of the token (e.g. \"CAT\")",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "OpenConfig": {
        "type": "object",
        "required": [
          "entry_fee",
          "exit_fee"
        ],
        "properties": {
          "entry_fee": {
            "description": "Percentage of capital put into the Reserve Pool during the Open phase when buying from the curve.",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "exit_fee": {
            "description": "Exit taxation ratio",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "ReserveToken": {
        "type": "object",
        "required": [
          "decimals",
          "denom"
        ],
        "properties": {
          "decimals": {
            "description": "Number of decimal places for the reserve token, needed for proper curve math. Same format as decimals above, eg. if it is uatom, where 1 unit is 10^-6 ATOM, use 6 here",
            "type": "integer",
            "format": "uint8",
            "minimum": 0.0
          },
          "denom": {
            "description": "Reserve token denom (only support native for now)",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "SupplyToken": {
        "type": "object",
        "required": [
          "decimals",
          "subdenom"
        ],
        "properties": {
          "decimals": {
            "description": "Number of decimal places for the supply token, needed for proper curve math. Default for token factory is 6",
            "type": "integer",
            "format": "uint8",
            "minimum": 0.0
          },
          "max_supply": {
            "anyOf": [
              {
                "$ref": "#/definitions/Uint128"
              },
              {
                "type": "null"
              }
            ]
          },
          "metadata": {
            "description": "Metadata for the supply token to create",
            "anyOf": [
              {
                "$ref": "#/definitions/NewDenomMetadata"
              },
              {
                "type": "null"
              }
            ]
          },
          "subdenom": {
            "description": "The denom to create for the supply token",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Buy will attempt to purchase as many supply tokens as possible. You must send only reserve tokens.",
        "type": "object",
        "required": [
          "buy"
        ],
        "properties": {
          "buy": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Sell burns supply tokens in return for the reserve token. You must send only supply tokens.",
        "type": "object",
        "required": [
          "sell"
        ],
        "properties": {
          "sell": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Donate will donate tokens to the funding pool. You must send only reserve tokens.",
        "type": "object",
        "required": [
          "donate"
        ],
        "properties": {
          "donate": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Withdraw will withdraw tokens from the funding pool.",
        "type": "object",
        "required": [
          "withdraw"
        ],
        "properties": {
          "withdraw": {
            "type": "object",
            "properties": {
              "amount": {
                "description": "The amount to withdraw (defaults to full amount).",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Sets (or unsets if set to None) the maximum supply",
        "type": "object",
        "required": [
          "update_max_supply"
        ],
        "properties": {
          "update_max_supply": {
            "type": "object",
            "properties": {
              "max_supply": {
                "description": "The maximum supply able to be minted.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Updates the curve type used for pricing tokens. Only callable by owner. TODO think about other potential limitations on this.",
        "type": "object",
        "required": [
          "update_curve"
        ],
        "properties": {
          "update_curve": {
            "type": "object",
            "required": [
              "curve_type"
            ],
            "properties": {
              "curve_type": {
                "$ref": "#/definitions/CurveType"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update the hatch phase allowlist. Only callable by owner.",
        "type": "object",
        "required": [
          "update_hatch_allowlist"
        ],
        "properties": {
          "update_hatch_allowlist": {
            "type": "object",
            "required": [
              "to_add",
              "to_remove"
            ],
            "properties": {
              "to_add": {
                "description": "Addresses to be added.",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/HatcherAllowlistEntryMsg"
                }
              },
              "to_remove": {
                "description": "Addresses to be removed.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Toggles the paused state (circuit breaker)",
        "type": "object",
        "required": [
          "toggle_pause"
        ],
        "properties": {
          "toggle_pause": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update the funding pool forwarding. Only callable by owner.",
        "type": "object",
        "required": [
          "update_funding_pool_forwarding"
        ],
        "properties": {
          "update_funding_pool_forwarding": {
            "type": "object",
            "properties": {
              "address": {
                "description": "The address to receive the funding pool forwarding. Set to None to stop forwarding.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update the configuration of a certain phase. This can only be called by the owner.",
        "type": "object",
        "required": [
          "update_phase_config"
        ],
        "properties": {
          "update_phase_config": {
            "$ref": "#/definitions/UpdatePhaseConfigMsg"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Closing the bonding curve means no more buys are enabled and exit tax is set to zero. For example, this could be used in the event of a project shutting down.",
        "type": "object",
        "required": [
          "close"
        ],
        "properties": {
          "close": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update the contract's ownership. The `action` to be provided can be either to propose transferring ownership to an account, accept a pending ownership transfer, or renounce the ownership permanently.",
        "type": "object",
        "required": [
          "update_ownership"
        ],
        "properties": {
          "update_ownership": {
            "$ref": "#/definitions/Action"
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Action": {
        "description": "Actions that can be taken to alter the contract's ownership",
        "oneOf": [
          {
            "description": "Propose to transfer the contract's ownership to another account, optionally with an expiry time.\n\nCan only be called by the contract's current owner.\n\nAny existing pending ownership transfer is overwritten.",
            "type": "object",
            "required": [
              "transfer_ownership"
            ],
            "properties": {
              "transfer_ownership": {
                "type": "object",
                "required": [
                  "new_owner"
                ],
                "properties": {
                  "expiry": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Expiration"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "new_owner": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Accept the pending ownership transfer.\n\nCan only be called by the pending owner.",
            "type": "string",
            "enum": [
              "accept_ownership"
            ]
          },
          {
            "description": "Give up the contract's ownership and the possibility of appointing a new owner.\n\nCan only be invoked by the contract's current owner.\n\nAny existing pending ownership transfer is canceled.",
            "type": "string",
            "enum": [
              "renounce_ownership"
            ]
          }
        ]
      },
      "CurveType": {
        "oneOf": [
          {
            "description": "Constant always returns `value * 10^-scale` as spot price",
            "type": "object",
            "required": [
              "constant"
            ],
            "properties": {
              "constant": {
                "type": "object",
                "required": [
                  "scale",
                  "value"
                ],
                "properties": {
                  "scale": {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "value": {
                    "$ref": "#/definitions/Uint128"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Linear returns `slope * 10^-scale * supply` as spot price",
            "type": "object",
            "required": [
              "linear"
            ],
            "properties": {
              "linear": {
                "type": "object",
                "required": [
                  "scale",
                  "slope"
                ],
                "properties": {
                  "scale": {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "slope": {
                    "$ref": "#/definitions/Uint128"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "SquareRoot returns `slope * 10^-scale * supply^0.5` as spot price",
            "type": "object",
            "required": [
              "square_root"
            ],
            "properties": {
              "square_root": {
                "type": "object",
                "required": [
                  "scale",
                  "slope"
                ],
                "properties": {
                  "scale": {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "slope": {
                    "$ref": "#/definitions/Uint128"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Expiration": {
        "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
        "oneOf": [
          {
            "description": "AtHeight will expire when `env.block.height` >= height",
            "type": "object",
            "required": [
              "at_height"
            ],
            "properties": {
              "at_height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "AtTime will expire when `env.block.time` >= time",
            "type": "object",
            "required": [
              "at_time"
            ],
            "properties": {
              "at_time": {
                "$ref": "#/definitions/Timestamp"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Never will never expire. Used to express the empty variant",
            "type": "object",
            "required": [
              "never"
            ],
            "properties": {
              "never": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "HatcherAllowlistConfigMsg": {
        "type": "object",
        "required": [
          "config_type"
        ],
        "properties": {
          "config_type": {
            "description": "The type of the configuration",
            "allOf": [
              {
                "$ref": "#/definitions/HatcherAllowlistConfigType"
              }
            ]
          },
          "contribution_limits_override": {
            "description": "An optional override of the hatch_config's contribution limit",
            "anyOf": [
              {
                "$ref": "#/definitions/MinMax"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "HatcherAllowlistConfigType": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "d_a_o"
            ],
            "properties": {
              "d_a_o": {
                "type": "object",
                "properties": {
                  "priority": {
                    "description": "The optional priority for checking a DAO config None will append the item to the end of the priority queue (least priority)",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Uint64"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "HatcherAllowlistEntryMsg": {
        "type": "object",
        "required": [
          "addr",
          "config"
        ],
        "properties": {
          "addr": {
            "type": "string"
          },
          "config": {
            "$ref": "#/definitions/HatcherAllowlistConfigMsg"
          }
        },
        "additionalProperties": false
      },
      "MinMax": {
        "description": "Struct for minimum and maximum values",
        "type": "object",
        "required": [
          "max",
          "min"
        ],
        "properties": {
          "max": {
            "$ref": "#/definitions/Uint128"
          },
          "min": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "additionalProperties": false
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      },
      "UpdatePhaseConfigMsg": {
        "description": "Update the phase configurations. These can only be called by the owner.",
        "oneOf": [
          {
            "description": "Update the hatch phase configuration",
            "type": "object",
            "required": [
              "hatch"
            ],
            "properties": {
              "hatch": {
                "type": "object",
                "properties": {
                  "contribution_limits": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/MinMax"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "entry_fee": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Decimal"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "initial_raise": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/MinMax"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Update the open phase configuration.",
            "type": "object",
            "required": [
              "open"
            ],
            "properties": {
              "open": {
                "type": "object",
                "properties": {
                  "entry_fee": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Decimal"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "exit_fee": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Decimal"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Update the closed phase configuration. TODO Set the curve type to be used on close?",
            "type": "object",
            "required": [
              "closed"
            ],
            "properties": {
              "closed": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Returns the reserve and supply quantities, as well as the spot price to buy 1 token Returns [`CurveInfoResponse`]",
        "type": "object",
        "required": [
          "curve_info"
        ],
        "properties": {
          "curve_info": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns information about the curve type (i.e. linear, constant, etc.)",
        "type": "object",
        "required": [
          "curve_type"
        ],
        "properties": {
          "curve_type": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns Token Factory Denom for the supply",
        "type": "object",
        "required": [
          "denom"
        ],
        "properties": {
          "denom": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns a list of the donors and their donations Returns [`DonationsResponse`]",
        "type": "object",
        "required": [
          "donations"
        ],
        "properties": {
          "donations": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "is_paused"
        ],
        "properties": {
          "is_paused": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the funding pool forwarding config for the contract. This is the address that receives any fees collected from bonding curve operation and donations",
        "type": "object",
        "required": [
          "funding_pool_forwarding"
        ],
        "properties": {
          "funding_pool_forwarding": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List the hatchers and their contributions Returns [`HatchersResponse`]",
        "type": "object",
        "required": [
          "hatchers"
        ],
        "properties": {
          "hatchers": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the contribution of a hatcher",
        "type": "object",
        "required": [
          "hatcher"
        ],
        "properties": {
          "hatcher": {
            "type": "object",
            "required": [
              "addr"
            ],
            "properties": {
              "addr": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Lists the hatcher allowlist Returns [`HatcherAllowlistResponse`]",
        "type": "object",
        "required": [
          "hatcher_allowlist"
        ],
        "properties": {
          "hatcher_allowlist": {
            "type": "object",
            "properties": {
              "config_type": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/HatcherAllowlistConfigType"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the Maximum Supply of the supply token",
        "type": "object",
        "required": [
          "max_supply"
        ],
        "properties": {
          "max_supply": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the amount of tokens to receive from buying",
        "type": "object",
        "required": [
          "buy_quote"
        ],
        "properties": {
          "buy_quote": {
            "type": "object",
            "required": [
              "payment"
            ],
            "properties": {
              "payment": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the amount of tokens to receive from selling",
        "type": "object",
        "required": [
          "sell_quote"
        ],
        "properties": {
          "sell_quote": {
            "type": "object",
            "required": [
              "payment"
            ],
            "properties": {
              "payment": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the current phase",
        "type": "object",
        "required": [
          "phase"
        ],
        "properties": {
          "phase": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the current phase configuration Returns [`CommonsPhaseConfigResponse`]",
        "type": "object",
        "required": [
          "phase_config"
        ],
        "properties": {
          "phase_config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the address of the cw-tokenfactory-issuer contract",
        "type": "object",
        "required": [
          "token_contract"
        ],
        "properties": {
          "token_contract": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query the contract's ownership information",
        "type": "object",
        "required": [
          "ownership"
        ],
        "properties": {
          "ownership": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "HatcherAllowlistConfigType": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "d_a_o"
            ],
            "properties": {
              "d_a_o": {
                "type": "object",
                "properties": {
                  "priority": {
                    "description": "The optional priority for checking a DAO config None will append the item to the end of the priority queue (least priority)",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Uint64"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "buy_quote": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "QuoteResponse",
      "type": "object",
      "required": [
        "amount",
        "funded",
        "new_reserve",
        "new_supply"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "funded": {
          "$ref": "#/definitions/Uint128"
        },
        "new_reserve": {
          "$ref": "#/definitions/Uint128"
        },
        "new_supply": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "curve_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "CurveInfoResponse",
      "type": "object",
      "required": [
        "funding",
        "reserve",
        "reserve_denom",
        "spot_price",
        "supply"
      ],
      "properties": {
        "funding": {
          "description": "The amount of tokens in the funding pool",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "reserve": {
          "description": "How many reserve tokens have been received",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "reserve_denom": {
          "description": "Current reserve denom",
          "type": "string"
        },
        "spot_price": {
          "description": "Current spot price of the token",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "supply": {
          "description": "How many supply tokens have been issued",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "curve_type": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "CurveType",
      "oneOf": [
        {
          "description": "Constant always returns `value * 10^-scale` as spot price",
          "type": "object",
          "required": [
            "constant"
          ],
          "properties": {
            "constant": {
              "type": "object",
              "required": [
                "scale",
                "value"
              ],
              "properties": {
                "scale": {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                },
                "value": {
                  "$ref": "#/definitions/Uint128"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Linear returns `slope * 10^-scale * supply` as spot price",
          "type": "object",
          "required": [
            "linear"
          ],
          "properties": {
            "linear": {
              "type": "object",
              "required": [
                "scale",
                "slope"
              ],
              "properties": {
                "scale": {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                },
                "slope": {
                  "$ref": "#/definitions/Uint128"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "description": "SquareRoot returns `slope * 10^-scale * supply^0.5` as spot price",
          "type": "object",
          "required": [
            "square_root"
          ],
          "properties": {
            "square_root": {
              "type": "object",
              "required": [
                "scale",
                "slope"
              ],
              "properties": {
                "scale": {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                },
                "slope": {
                  "$ref": "#/definitions/Uint128"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "denom": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DenomResponse",
      "type": "object",
      "required": [
        "denom"
      ],
      "properties": {
        "denom": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "donations": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DonationsResponse",
      "type": "object",
      "required": [
        "donations"
      ],
      "properties": {
        "donations": {
          "description": "The donators mapped to their donation in the reserve token",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "$ref": "#/definitions/Addr"
              },
              {
                "$ref": "#/definitions/Uint128"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "funding_pool_forwarding": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_Addr",
      "anyOf": [
        {
          "$ref": "#/definitions/Addr"
        },
        {
          "type": "null"
        }
      ],
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "hatcher": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Uint128",
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "hatcher_allowlist": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "HatcherAllowlistResponse",
      "type": "object",
      "properties": {
        "allowlist": {
          "description": "Hatcher allowlist",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/HatcherAllowlistEntry"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "HatcherAllowlistConfig": {
          "description": "The configuration for a member of the hatcher allowlist",
          "type": "object",
          "required": [
            "config_height",
            "config_type"
          ],
          "properties": {
            "config_height": {
              "description": "The height of the config insertion For use when checking allowlist of DAO configs",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "config_type": {
              "description": "The type of the configuration",
              "allOf": [
                {
                  "$ref": "#/definitions/HatcherAllowlistConfigType"
                }
              ]
            },
            "contribution_limits_override": {
              "description": "An optional override of the hatch_config's contribution limit",
              "anyOf": [
                {
                  "$ref": "#/definitions/MinMax"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "HatcherAllowlistConfigType": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "d_a_o"
              ],
              "properties": {
                "d_a_o": {
                  "type": "object",
                  "properties": {
                    "priority": {
                      "description": "The optional priority for checking a DAO config None will append the item to the end of the priority queue (least priority)",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Uint64"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "address"
              ],
              "properties": {
                "address": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "HatcherAllowlistEntry": {
          "type": "object",
          "required": [
            "addr",
            "config"
          ],
          "properties": {
            "addr": {
              "$ref": "#/definitions/Addr"
            },
            "config": {
              "$ref": "#/definitions/HatcherAllowlistConfig"
            }
          },
          "additionalProperties": false
        },
        "MinMax": {
          "description": "Struct for minimum and maximum values",
          "type": "object",
          "required": [
            "max",
            "min"
          ],
          "properties": {
            "max": {
              "$ref": "#/definitions/Uint128"
            },
            "min": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "hatchers": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "HatchersResponse",
      "type": "object",
      "required": [
        "hatchers"
      ],
      "properties": {
        "hatchers": {
          "description": "The hatchers mapped to their contribution in the reserve token",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "$ref": "#/definitions/Addr"
              },
              {
                "$ref": "#/definitions/Uint128"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "is_paused": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Boolean",
      "type": "boolean"
    },
    "max_supply": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Uint128",
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "ownership": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Ownership_for_String",
      "description": "The contract's ownership info",
      "type": "object",
      "properties": {
        "owner": {
          "description": "The contract's current owner. `None` if the ownership has been renounced.",
          "type": [
            "string",
            "null"
          ]
        },
        "pending_expiry": {
          "description": "The deadline for the pending owner to accept the ownership. `None` if there isn't a pending ownership transfer, or if a transfer exists and it doesn't have a deadline.",
          "anyOf": [
            {
              "$ref": "#/definitions/Expiration"
            },
            {
              "type": "null"
            }
          ]
        },
        "pending_owner": {
          "description": "The account who has been proposed to take over the ownership. `None` if there isn't a pending ownership transfer.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "phase": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "CommonsPhase",
      "type": "string",
      "enum": [
        "hatch",
        "open",
        "closed"
      ]
    },
    "phase_config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "CommonsPhaseConfigResponse",
      "type": "object",
      "required": [
        "phase",
        "phase_config"
      ],
      "properties": {
        "phase": {
          "description": "Current phase",
          "allOf": [
            {
              "$ref": "#/definitions/CommonsPhase"
            }
          ]
        },
        "phase_config": {
          "description": "The phase configuration",
          "allOf": [
            {
              "$ref": "#/definitions/CommonsPhaseConfig"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "ClosedConfig": {
          "type": "object",
          "additionalProperties": false
        },
        "CommonsPhase": {
          "type": "string",
          "enum": [
            "hatch",
            "open",
            "closed"
          ]
        },
        "CommonsPhaseConfig": {
          "type": "object",
          "required": [
            "closed",
            "hatch",
            "open"
          ],
          "properties": {
            "closed": {
              "description": "The Closed phase where the Commons is closed to new members.",
              "allOf": [
                {
                  "$ref": "#/definitions/ClosedConfig"
                }
              ]
            },
            "hatch": {
              "description": "The Hatch phase where initial contributors (Hatchers) participate in a hatch sale.",
              "allOf": [
                {
                  "$ref": "#/definitions/HatchConfig"
                }
              ]
            },
            "open": {
              "description": "TODO Vest tokens after hatch phase The Vesting phase where tokens minted during the Hatch phase are locked (burning is disabled) to combat early speculation/arbitrage. pub vesting: VestingConfig, The Open phase where anyone can mint tokens by contributing the reserve token into the curve and becoming members of the Commons.",
              "allOf": [
                {
                  "$ref": "#/definitions/OpenConfig"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "HatchConfig": {
          "type": "object",
          "required": [
            "contribution_limits",
            "entry_fee",
            "initial_raise"
          ],
          "properties": {
            "contribution_limits": {
              "description": "The minimum and maximum contribution amounts (min, max) in the reserve token",
              "allOf": [
                {
                  "$ref": "#/definitions/MinMax"
                }
              ]
            },
            "entry_fee": {
              "description": "The initial allocation (Î¸), percentage of the initial raise allocated to the Funding Pool",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "initial_raise": {
              "description": "The initial raise range (min, max) in the reserve token",
              "allOf": [
                {
                  "$ref": "#/definitions/MinMax"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MinMax": {
          "description": "Struct for minimum and maximum values",
          "type": "object",
          "required": [
            "max",
            "min"
          ],
          "properties": {
            "max": {
              "$ref": "#/definitions/Uint128"
            },
            "min": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "OpenConfig": {
          "type": "object",
          "required": [
            "entry_fee",
            "exit_fee"
          ],
          "properties": {
            "entry_fee": {
              "description": "Percentage of capital put into the Reserve Pool during the Open phase when buying from the curve.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "exit_fee": {
              "description": "Exit taxation ratio",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "sell_quote": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "QuoteResponse",
      "type": "object",
      "required": [
        "amount",
        "funded",
        "new_reserve",
        "new_supply"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "funded": {
          "$ref": "#/definitions/Uint128"
        },
        "new_reserve": {
          "$ref": "#/definitions/Uint128"
        },
        "new_supply": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "token_contract": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    }
  }
}
