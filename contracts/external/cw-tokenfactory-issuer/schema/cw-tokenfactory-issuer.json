{
  "contract_name": "cw-tokenfactory-issuer",
  "contract_version": "2.5.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "The message used to create a new instance of this smart contract.",
    "oneOf": [
      {
        "description": "`NewToken` will create a new token when instantiate the contract. Newly created token will have full denom as `factory/<contract_address>/<subdenom>`. It will be attached to the contract setup the beforesend listener automatically.",
        "type": "object",
        "required": [
          "new_token"
        ],
        "properties": {
          "new_token": {
            "type": "object",
            "required": [
              "subdenom"
            ],
            "properties": {
              "subdenom": {
                "description": "component of fulldenom (`factory/<contract_address>/<subdenom>`).",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "`ExistingToken` will use already created token. So to set this up, Token Factory admin for the existing token needs trasfer admin over to this contract, and optionally set the `BeforeSendHook` manually.",
        "type": "object",
        "required": [
          "existing_token"
        ],
        "properties": {
          "existing_token": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "description": "State changing methods available to this smart contract.",
    "oneOf": [
      {
        "description": "Allow adds the target address to the allowlist to be able to send or recieve tokens even if the token is frozen. Token Factory's BeforeSendHook listener must be set to this contract in order for this feature to work.\n\nThis functionality is intedended for DAOs who do not wish to have a their tokens liquid while bootstrapping their DAO. For example, a DAO may wish to white list a Token Staking contract (to allow users to stake their tokens in the DAO) or a Merkle Drop contract (to allow users to claim their tokens).",
        "type": "object",
        "required": [
          "allow"
        ],
        "properties": {
          "allow": {
            "type": "object",
            "required": [
              "address",
              "status"
            ],
            "properties": {
              "address": {
                "type": "string"
              },
              "status": {
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Burn token to address. Burn allowance is required and wiil be deducted after successful burn.",
        "type": "object",
        "required": [
          "burn"
        ],
        "properties": {
          "burn": {
            "type": "object",
            "required": [
              "amount",
              "from_address"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              },
              "from_address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Mint token to address. Mint allowance is required and wiil be deducted after successful mint.",
        "type": "object",
        "required": [
          "mint"
        ],
        "properties": {
          "mint": {
            "type": "object",
            "required": [
              "amount",
              "to_address"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              },
              "to_address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Deny adds the target address to the denylist, whis prevents them from sending/receiving the token attached to this contract tokenfactory's BeforeSendHook listener must be set to this contract in order for this feature to work as intended.",
        "type": "object",
        "required": [
          "deny"
        ],
        "properties": {
          "deny": {
            "type": "object",
            "required": [
              "address",
              "status"
            ],
            "properties": {
              "address": {
                "type": "string"
              },
              "status": {
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Block every token transfers of the token attached to this contract. Token Factory's BeforeSendHook listener must be set to this contract in order for this feature to work as intended.",
        "type": "object",
        "required": [
          "freeze"
        ],
        "properties": {
          "freeze": {
            "type": "object",
            "required": [
              "status"
            ],
            "properties": {
              "status": {
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Force transfer token from one address to another.",
        "type": "object",
        "required": [
          "force_transfer"
        ],
        "properties": {
          "force_transfer": {
            "type": "object",
            "required": [
              "amount",
              "from_address",
              "to_address"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              },
              "from_address": {
                "type": "string"
              },
              "to_address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Attempt to SetBeforeSendHook on the token attached to this contract. This will fail if the chain does not support bank module hooks (many Token Factory implementations do not yet support).\n\nThis takes a cosmwasm_address as an argument, which is the address of the contract that will be called before every token transfer. Normally, this will be the issuer contract itself, though it can be a custom contract for greater flexibility.\n\nSetting the address to an empty string will remove the SetBeforeSendHook.\n\nThis method can only be called by the contract owner.",
        "type": "object",
        "required": [
          "set_before_send_hook"
        ],
        "properties": {
          "set_before_send_hook": {
            "type": "object",
            "required": [
              "cosmwasm_address"
            ],
            "properties": {
              "cosmwasm_address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Grant/revoke burn allowance.",
        "type": "object",
        "required": [
          "set_burner_allowance"
        ],
        "properties": {
          "set_burner_allowance": {
            "type": "object",
            "required": [
              "address",
              "allowance"
            ],
            "properties": {
              "address": {
                "type": "string"
              },
              "allowance": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Set denom metadata. see: https://docs.cosmos.network/main/modules/bank#denom-metadata.",
        "type": "object",
        "required": [
          "set_denom_metadata"
        ],
        "properties": {
          "set_denom_metadata": {
            "type": "object",
            "required": [
              "metadata"
            ],
            "properties": {
              "metadata": {
                "$ref": "#/definitions/Metadata"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Grant/revoke mint allowance.",
        "type": "object",
        "required": [
          "set_minter_allowance"
        ],
        "properties": {
          "set_minter_allowance": {
            "type": "object",
            "required": [
              "address",
              "allowance"
            ],
            "properties": {
              "address": {
                "type": "string"
              },
              "allowance": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Updates the admin of the Token Factory token. Normally this is the cw-tokenfactory-issuer contract itself. This is intended to be used only if you seek to transfer ownership of the Token somewhere else (i.e. to another management contract).",
        "type": "object",
        "required": [
          "update_token_factory_admin"
        ],
        "properties": {
          "update_token_factory_admin": {
            "type": "object",
            "required": [
              "new_admin"
            ],
            "properties": {
              "new_admin": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Updates the owner of this contract who is allowed to call privileged methods. NOTE: this is separate from the Token Factory token admin, for this contract to work at all, it needs to the be the Token Factory token admin.\n\nNormally, the contract owner will be a DAO.\n\nThe `action` to be provided can be either to propose transferring ownership to an account, accept a pending ownership transfer, or renounce the ownership permanently.",
        "type": "object",
        "required": [
          "update_ownership"
        ],
        "properties": {
          "update_ownership": {
            "$ref": "#/definitions/Action"
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Action": {
        "description": "Actions that can be taken to alter the contract's ownership",
        "oneOf": [
          {
            "description": "Propose to transfer the contract's ownership to another account, optionally with an expiry time.\n\nCan only be called by the contract's current owner.\n\nAny existing pending ownership transfer is overwritten.",
            "type": "object",
            "required": [
              "transfer_ownership"
            ],
            "properties": {
              "transfer_ownership": {
                "type": "object",
                "required": [
                  "new_owner"
                ],
                "properties": {
                  "expiry": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Expiration"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "new_owner": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Accept the pending ownership transfer.\n\nCan only be called by the pending owner.",
            "type": "string",
            "enum": [
              "accept_ownership"
            ]
          },
          {
            "description": "Give up the contract's ownership and the possibility of appointing a new owner.\n\nCan only be invoked by the contract's current owner.\n\nAny existing pending ownership transfer is canceled.",
            "type": "string",
            "enum": [
              "renounce_ownership"
            ]
          }
        ]
      },
      "DenomUnit": {
        "description": "DenomUnit represents a struct that describes a given denomination unit of the basic token.",
        "type": "object",
        "required": [
          "aliases",
          "denom",
          "exponent"
        ],
        "properties": {
          "aliases": {
            "description": "aliases is a list of string aliases for the given denom",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "denom": {
            "description": "denom represents the string name of the given denom unit (e.g uatom).",
            "type": "string"
          },
          "exponent": {
            "description": "exponent represents power of 10 exponent that one must raise the base_denom to in order to equal the given DenomUnit's denom 1 denom = 10^exponent base_denom (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with exponent = 6, thus: 1 atom = 10^6 uatom).",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          }
        }
      },
      "Expiration": {
        "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
        "oneOf": [
          {
            "description": "AtHeight will expire when `env.block.height` >= height",
            "type": "object",
            "required": [
              "at_height"
            ],
            "properties": {
              "at_height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "AtTime will expire when `env.block.time` >= time",
            "type": "object",
            "required": [
              "at_time"
            ],
            "properties": {
              "at_time": {
                "$ref": "#/definitions/Timestamp"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Never will never expire. Used to express the empty variant",
            "type": "object",
            "required": [
              "never"
            ],
            "properties": {
              "never": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Metadata": {
        "description": "Metadata represents a struct that describes a basic token.",
        "type": "object",
        "required": [
          "base",
          "denom_units",
          "description",
          "display",
          "name",
          "symbol",
          "uri",
          "uri_hash"
        ],
        "properties": {
          "base": {
            "description": "base represents the base denom (should be the DenomUnit with exponent = 0).",
            "type": "string"
          },
          "denom_units": {
            "description": "denom_units represents the list of DenomUnit's for a given coin",
            "type": "array",
            "items": {
              "$ref": "#/definitions/DenomUnit"
            }
          },
          "description": {
            "type": "string"
          },
          "display": {
            "description": "display indicates the suggested denom that should be displayed in clients.",
            "type": "string"
          },
          "name": {
            "description": "name defines the name of the token (eg: Cosmos Atom)\n\nSince: cosmos-sdk 0.43",
            "type": "string"
          },
          "symbol": {
            "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can be the same as the display.\n\nSince: cosmos-sdk 0.43",
            "type": "string"
          },
          "uri": {
            "description": "URI to a document (on or off-chain) that contains additional information. Optional.\n\nSince: cosmos-sdk 0.46",
            "type": "string"
          },
          "uri_hash": {
            "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that the document didn't change. Optional.\n\nSince: cosmos-sdk 0.46",
            "type": "string"
          }
        }
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "description": "Queries supported by this smart contract.",
    "oneOf": [
      {
        "description": "Returns if token transfer is disabled. Response: IsFrozenResponse",
        "type": "object",
        "required": [
          "is_frozen"
        ],
        "properties": {
          "is_frozen": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the token denom that this contract is the admin for. Response: DenomResponse",
        "type": "object",
        "required": [
          "denom"
        ],
        "properties": {
          "denom": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "ownership"
        ],
        "properties": {
          "ownership": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the burn allowance of the specified address. Response: AllowanceResponse",
        "type": "object",
        "required": [
          "burn_allowance"
        ],
        "properties": {
          "burn_allowance": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enumerates over all burn allownances. Response: AllowancesResponse",
        "type": "object",
        "required": [
          "burn_allowances"
        ],
        "properties": {
          "burn_allowances": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the mint allowance of the specified user. Response: AllowanceResponse",
        "type": "object",
        "required": [
          "mint_allowance"
        ],
        "properties": {
          "mint_allowance": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enumerates over all mint allownances. Response: AllowancesResponse",
        "type": "object",
        "required": [
          "mint_allowances"
        ],
        "properties": {
          "mint_allowances": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns wether the user is on denylist or not. Response: StatusResponse",
        "type": "object",
        "required": [
          "is_denied"
        ],
        "properties": {
          "is_denied": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enumerates over all addresses on the denylist. Response: DenylistResponse",
        "type": "object",
        "required": [
          "denylist"
        ],
        "properties": {
          "denylist": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns wether the user is on the allowlist or not. Response: StatusResponse",
        "type": "object",
        "required": [
          "is_allowed"
        ],
        "properties": {
          "is_allowed": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enumerates over all addresses on the allowlist. Response: AllowlistResponse",
        "type": "object",
        "required": [
          "allowlist"
        ],
        "properties": {
          "allowlist": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns information about the BeforeSendHook for the token. Note: many Token Factory chains do not yet support this feature.\n\nThe information returned is: - Whether features in this contract that require MsgBeforeSendHook are enabled. - The address of the BeforeSendHook contract if configured.\n\nResponse: BeforeSendHookInfo",
        "type": "object",
        "required": [
          "before_send_hook_info"
        ],
        "properties": {
          "before_send_hook_info": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": null,
  "sudo": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "SudoMsg",
    "description": "SudoMsg is only exposed for internal Cosmos SDK modules to call. This is showing how we can expose \"admin\" functionality than can not be called by external users or contracts, but only trusted (native/Go) code in the blockchain",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "block_before_send"
        ],
        "properties": {
          "block_before_send": {
            "type": "object",
            "required": [
              "amount",
              "from",
              "to"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Coin"
              },
              "from": {
                "type": "string"
              },
              "to": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "responses": {
    "allowlist": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AllowlistResponse",
      "description": "Returns a list of addresses currently on the allowlist",
      "type": "object",
      "required": [
        "allowlist"
      ],
      "properties": {
        "allowlist": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/StatusInfo"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "StatusInfo": {
          "description": "Account info for list queries related to allowlist and denylist",
          "type": "object",
          "required": [
            "address",
            "status"
          ],
          "properties": {
            "address": {
              "type": "string"
            },
            "status": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      }
    },
    "before_send_hook_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BeforeSendHookInfo",
      "description": "Whether or not features that require MsgBeforeSendHook are enabled Many Token Factory chains do not yet support MsgBeforeSendHook",
      "type": "object",
      "required": [
        "advanced_features_enabled"
      ],
      "properties": {
        "advanced_features_enabled": {
          "description": "Whether or not features in this contract that require MsgBeforeSendHook are enabled.",
          "type": "boolean"
        },
        "hook_contract_address": {
          "description": "The address of the contract that implements the BeforeSendHook interface. Most often this will be the cw_tokenfactory_issuer contract itself.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "burn_allowance": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AllowanceResponse",
      "description": "Returns a mint or burn allowance for a particular address, representing the amount of tokens the account is allowed to mint or burn",
      "type": "object",
      "required": [
        "allowance"
      ],
      "properties": {
        "allowance": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "burn_allowances": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AllowancesResponse",
      "description": "Returns a list of all mint or burn allowances",
      "type": "object",
      "required": [
        "allowances"
      ],
      "properties": {
        "allowances": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AllowanceInfo"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "AllowanceInfo": {
          "description": "Information about a particular account and its mint / burn allowances. Used in list queries.",
          "type": "object",
          "required": [
            "address",
            "allowance"
          ],
          "properties": {
            "address": {
              "type": "string"
            },
            "allowance": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "denom": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DenomResponse",
      "description": "Returns the full denomination for the Token Factory token. For example: `factory/{contract address}/{subdenom}`",
      "type": "object",
      "required": [
        "denom"
      ],
      "properties": {
        "denom": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "denylist": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DenylistResponse",
      "description": "Returns a list of addresses currently on the denylist.",
      "type": "object",
      "required": [
        "denylist"
      ],
      "properties": {
        "denylist": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/StatusInfo"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "StatusInfo": {
          "description": "Account info for list queries related to allowlist and denylist",
          "type": "object",
          "required": [
            "address",
            "status"
          ],
          "properties": {
            "address": {
              "type": "string"
            },
            "status": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      }
    },
    "is_allowed": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StatusResponse",
      "description": "Whether a particular account is allowed or denied",
      "type": "object",
      "required": [
        "status"
      ],
      "properties": {
        "status": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "is_denied": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StatusResponse",
      "description": "Whether a particular account is allowed or denied",
      "type": "object",
      "required": [
        "status"
      ],
      "properties": {
        "status": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "is_frozen": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "IsFrozenResponse",
      "description": "Returns whether or not the Token Factory token is frozen and transfers are disabled.",
      "type": "object",
      "required": [
        "is_frozen"
      ],
      "properties": {
        "is_frozen": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "mint_allowance": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AllowanceResponse",
      "description": "Returns a mint or burn allowance for a particular address, representing the amount of tokens the account is allowed to mint or burn",
      "type": "object",
      "required": [
        "allowance"
      ],
      "properties": {
        "allowance": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "mint_allowances": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AllowancesResponse",
      "description": "Returns a list of all mint or burn allowances",
      "type": "object",
      "required": [
        "allowances"
      ],
      "properties": {
        "allowances": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AllowanceInfo"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "AllowanceInfo": {
          "description": "Information about a particular account and its mint / burn allowances. Used in list queries.",
          "type": "object",
          "required": [
            "address",
            "allowance"
          ],
          "properties": {
            "address": {
              "type": "string"
            },
            "allowance": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "ownership": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Ownership_for_Addr",
      "description": "The contract's ownership info",
      "type": "object",
      "properties": {
        "owner": {
          "description": "The contract's current owner. `None` if the ownership has been renounced.",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        },
        "pending_expiry": {
          "description": "The deadline for the pending owner to accept the ownership. `None` if there isn't a pending ownership transfer, or if a transfer exists and it doesn't have a deadline.",
          "anyOf": [
            {
              "$ref": "#/definitions/Expiration"
            },
            {
              "type": "null"
            }
          ]
        },
        "pending_owner": {
          "description": "The account who has been proposed to take over the ownership. `None` if there isn't a pending ownership transfer.",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
