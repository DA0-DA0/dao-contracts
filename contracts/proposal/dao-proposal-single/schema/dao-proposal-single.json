{
  "contract_name": "dao-proposal-single",
  "contract_version": "2.5.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "allow_revoting",
      "close_proposal_on_execution_failure",
      "max_voting_period",
      "only_members_execute",
      "pre_propose_info",
      "threshold"
    ],
    "properties": {
      "allow_revoting": {
        "description": "Allows changing votes before the proposal expires. If this is enabled proposals will not be able to complete early as final vote information is not known until the time of proposal expiration.",
        "type": "boolean"
      },
      "close_proposal_on_execution_failure": {
        "description": "If set to true proposals will be closed if their execution fails. Otherwise, proposals will remain open after execution failure. For example, with this enabled a proposal to send 5 tokens out of a DAO's treasury with 4 tokens would be closed when it is executed. With this disabled, that same proposal would remain open until the DAO's treasury was large enough for it to be executed.",
        "type": "boolean"
      },
      "delegation_module": {
        "description": "The address of the delegation module to use for this proposal module (if any).",
        "type": [
          "string",
          "null"
        ]
      },
      "max_voting_period": {
        "description": "The default maximum amount of time a proposal may be voted on before expiring.",
        "allOf": [
          {
            "$ref": "#/definitions/Duration"
          }
        ]
      },
      "min_voting_period": {
        "description": "The minimum amount of time a proposal must be open before passing. A proposal may fail before this amount of time has elapsed, but it will not pass. This can be useful for preventing governance attacks wherein an attacker aquires a large number of tokens and forces a proposal through.",
        "anyOf": [
          {
            "$ref": "#/definitions/Duration"
          },
          {
            "type": "null"
          }
        ]
      },
      "only_members_execute": {
        "description": "If set to true only members may execute passed proposals. Otherwise, any address may execute a passed proposal.",
        "type": "boolean"
      },
      "pre_propose_info": {
        "description": "Information about what addresses may create proposals.",
        "allOf": [
          {
            "$ref": "#/definitions/PreProposeInfo"
          }
        ]
      },
      "threshold": {
        "description": "The threshold a proposal must reach to complete.",
        "allOf": [
          {
            "$ref": "#/definitions/Threshold"
          }
        ]
      },
      "veto": {
        "description": "Optional veto configuration for proposal execution. If set, proposals can only be executed after the timelock delay expiration. During this period an oversight account (`veto.vetoer`) can veto the proposal.",
        "anyOf": [
          {
            "$ref": "#/definitions/VetoConfig"
          },
          {
            "type": "null"
          }
        ]
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Admin": {
        "description": "Information about the CosmWasm level admin of a contract. Used in conjunction with `ModuleInstantiateInfo` to instantiate modules.",
        "oneOf": [
          {
            "description": "Set the admin to a specified address.",
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "object",
                "required": [
                  "addr"
                ],
                "properties": {
                  "addr": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sets the admin as the core module address.",
            "type": "object",
            "required": [
              "core_module"
            ],
            "properties": {
              "core_module": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Duration": {
        "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "height"
            ],
            "properties": {
              "height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Time in seconds",
            "type": "object",
            "required": [
              "time"
            ],
            "properties": {
              "time": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ModuleInstantiateInfo": {
        "description": "Information needed to instantiate a module.",
        "type": "object",
        "required": [
          "code_id",
          "funds",
          "label",
          "msg"
        ],
        "properties": {
          "admin": {
            "description": "CosmWasm level admin of the instantiated contract. See: <https://docs.cosmwasm.com/docs/1.0/smart-contracts/migration>",
            "anyOf": [
              {
                "$ref": "#/definitions/Admin"
              },
              {
                "type": "null"
              }
            ]
          },
          "code_id": {
            "description": "Code ID of the contract to be instantiated.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "funds": {
            "description": "Funds to be sent to the instantiated contract.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Coin"
            }
          },
          "label": {
            "description": "Label for the instantiated contract.",
            "type": "string"
          },
          "msg": {
            "description": "Instantiate message to be used to create the contract.",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "PercentageThreshold": {
        "description": "A percentage of voting power that must vote yes for a proposal to pass. An example of why this is needed:\n\nIf a user specifies a 60% passing threshold, and there are 10 voters they likely expect that proposal to pass when there are 6 yes votes. This implies that the condition for passing should be `vote_weights >= total_votes * threshold`.\n\nWith this in mind, how should a user specify that they would like proposals to pass if the majority of voters choose yes? Selecting a 50% passing threshold with those rules doesn't properly cover that case as 5 voters voting yes out of 10 would pass the proposal. Selecting 50.0001% or or some variation of that also does not work as a very small yes vote which technically makes the majority yes may not reach that threshold.\n\nTo handle these cases we provide both a majority and percent option for all percentages. If majority is selected passing will be determined by `yes > total_votes * 0.5`. If percent is selected passing is determined by `yes >= total_votes * percent`.\n\nIn both of these cases a proposal with only abstain votes must fail. This requires a special case passing logic.",
        "oneOf": [
          {
            "description": "The majority of voters must vote yes for the proposal to pass.",
            "type": "object",
            "required": [
              "majority"
            ],
            "properties": {
              "majority": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "A percentage of voting power >= percent must vote yes for the proposal to pass.",
            "type": "object",
            "required": [
              "percent"
            ],
            "properties": {
              "percent": {
                "$ref": "#/definitions/Decimal"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "PreProposeInfo": {
        "oneOf": [
          {
            "description": "Anyone may create a proposal free of charge.",
            "type": "object",
            "required": [
              "anyone_may_propose"
            ],
            "properties": {
              "anyone_may_propose": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "The module specified in INFO has exclusive rights to proposal creation.",
            "type": "object",
            "required": [
              "module_may_propose"
            ],
            "properties": {
              "module_may_propose": {
                "type": "object",
                "required": [
                  "info"
                ],
                "properties": {
                  "info": {
                    "$ref": "#/definitions/ModuleInstantiateInfo"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Threshold": {
        "description": "The ways a proposal may reach its passing / failing threshold.",
        "oneOf": [
          {
            "description": "Declares a percentage of the total weight that must cast Yes votes in order for a proposal to pass.  See `ThresholdResponse::AbsolutePercentage` in the cw3 spec for details.",
            "type": "object",
            "required": [
              "absolute_percentage"
            ],
            "properties": {
              "absolute_percentage": {
                "type": "object",
                "required": [
                  "percentage"
                ],
                "properties": {
                  "percentage": {
                    "$ref": "#/definitions/PercentageThreshold"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Declares a `quorum` of the total votes that must participate in the election in order for the vote to be considered at all. See `ThresholdResponse::ThresholdQuorum` in the cw3 spec for details.",
            "type": "object",
            "required": [
              "threshold_quorum"
            ],
            "properties": {
              "threshold_quorum": {
                "type": "object",
                "required": [
                  "quorum",
                  "threshold"
                ],
                "properties": {
                  "quorum": {
                    "$ref": "#/definitions/PercentageThreshold"
                  },
                  "threshold": {
                    "$ref": "#/definitions/PercentageThreshold"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "An absolute number of votes needed for something to cross the threshold. Useful for multisig style voting.",
            "type": "object",
            "required": [
              "absolute_count"
            ],
            "properties": {
              "absolute_count": {
                "type": "object",
                "required": [
                  "threshold"
                ],
                "properties": {
                  "threshold": {
                    "$ref": "#/definitions/Uint128"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "VetoConfig": {
        "type": "object",
        "required": [
          "early_execute",
          "timelock_duration",
          "veto_before_passed",
          "vetoer"
        ],
        "properties": {
          "early_execute": {
            "description": "Whether or not the vetoer can execute a proposal early before the timelock duration has expired",
            "type": "boolean"
          },
          "timelock_duration": {
            "description": "The time duration to lock a proposal for after its expiration to allow the vetoer to veto.",
            "allOf": [
              {
                "$ref": "#/definitions/Duration"
              }
            ]
          },
          "veto_before_passed": {
            "description": "Whether or not the vetoer can veto a proposal before it passes.",
            "type": "boolean"
          },
          "vetoer": {
            "description": "The address able to veto proposals.",
            "type": "string"
          }
        },
        "additionalProperties": false
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Creates a proposal in the module.",
        "type": "object",
        "required": [
          "propose"
        ],
        "properties": {
          "propose": {
            "$ref": "#/definitions/SingleChoiceProposeMsg"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Votes on a proposal. Voting power is determined by the DAO's voting power module.",
        "type": "object",
        "required": [
          "vote"
        ],
        "properties": {
          "vote": {
            "type": "object",
            "required": [
              "proposal_id",
              "vote"
            ],
            "properties": {
              "proposal_id": {
                "description": "The ID of the proposal to vote on.",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "rationale": {
                "description": "An optional rationale for why this vote was cast. This can be updated, set, or removed later by the address casting the vote.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "vote": {
                "description": "The senders position on the proposal.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Vote"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Updates the sender's rationale for their vote on the specified proposal. Errors if no vote vote has been cast.",
        "type": "object",
        "required": [
          "update_rationale"
        ],
        "properties": {
          "update_rationale": {
            "type": "object",
            "required": [
              "proposal_id"
            ],
            "properties": {
              "proposal_id": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "rationale": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Causes the messages associated with a passed proposal to be executed by the DAO.",
        "type": "object",
        "required": [
          "execute"
        ],
        "properties": {
          "execute": {
            "type": "object",
            "required": [
              "proposal_id"
            ],
            "properties": {
              "proposal_id": {
                "description": "The ID of the proposal to execute.",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Callable only if veto is configured",
        "type": "object",
        "required": [
          "veto"
        ],
        "properties": {
          "veto": {
            "type": "object",
            "required": [
              "proposal_id"
            ],
            "properties": {
              "proposal_id": {
                "description": "The ID of the proposal to veto.",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Closes a proposal that has failed (either not passed or timed out). If applicable this will cause the proposal deposit associated wth said proposal to be returned.",
        "type": "object",
        "required": [
          "close"
        ],
        "properties": {
          "close": {
            "type": "object",
            "required": [
              "proposal_id"
            ],
            "properties": {
              "proposal_id": {
                "description": "The ID of the proposal to close.",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Updates the governance module's config.",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "required": [
              "allow_revoting",
              "close_proposal_on_execution_failure",
              "dao",
              "max_voting_period",
              "only_members_execute",
              "threshold"
            ],
            "properties": {
              "allow_revoting": {
                "description": "Allows changing votes before the proposal expires. If this is enabled proposals will not be able to complete early as final vote information is not known until the time of proposal expiration.",
                "type": "boolean"
              },
              "close_proposal_on_execution_failure": {
                "description": "If set to true proposals will be closed if their execution fails. Otherwise, proposals will remain open after execution failure. For example, with this enabled a proposal to send 5 tokens out of a DAO's treasury with 4 tokens would be closed when it is executed. With this disabled, that same proposal would remain open until the DAO's treasury was large enough for it to be executed.",
                "type": "boolean"
              },
              "dao": {
                "description": "The address if tge DAO that this governance module is associated with.",
                "type": "string"
              },
              "max_voting_period": {
                "description": "The default maximum amount of time a proposal may be voted on before expiring. This will only apply to proposals created after the config update.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Duration"
                  }
                ]
              },
              "min_voting_period": {
                "description": "The minimum amount of time a proposal must be open before passing. A proposal may fail before this amount of time has elapsed, but it will not pass. This can be useful for preventing governance attacks wherein an attacker aquires a large number of tokens and forces a proposal through.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Duration"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "only_members_execute": {
                "description": "If set to true only members may execute passed proposals. Otherwise, any address may execute a passed proposal. Applies to all outstanding and future proposals.",
                "type": "boolean"
              },
              "threshold": {
                "description": "The new proposal passing threshold. This will only apply to proposals created after the config update.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Threshold"
                  }
                ]
              },
              "veto": {
                "description": "Optional time delay on proposal execution, during which the proposal may be vetoed.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/VetoConfig"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update's the proposal creation policy used for this module. Only the DAO may call this method.",
        "type": "object",
        "required": [
          "update_pre_propose_info"
        ],
        "properties": {
          "update_pre_propose_info": {
            "type": "object",
            "required": [
              "info"
            ],
            "properties": {
              "info": {
                "$ref": "#/definitions/PreProposeInfo"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update's the address of the delegation module associated with this proposal module. Only the DAO may call this method.",
        "type": "object",
        "required": [
          "update_delegation_module"
        ],
        "properties": {
          "update_delegation_module": {
            "type": "object",
            "required": [
              "module"
            ],
            "properties": {
              "module": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Adds an address as a consumer of proposal hooks. Consumers of proposal hooks have hook messages executed on them whenever the status of a proposal changes or a proposal is created. If a consumer contract errors when handling a hook message it will be removed from the list of consumers.",
        "type": "object",
        "required": [
          "add_proposal_hook"
        ],
        "properties": {
          "add_proposal_hook": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Removes a consumer of proposal hooks.",
        "type": "object",
        "required": [
          "remove_proposal_hook"
        ],
        "properties": {
          "remove_proposal_hook": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Adds an address as a consumer of vote hooks. Consumers of vote hooks have hook messages executed on them whenever the a vote is cast. If a consumer contract errors when handling a hook message it will be removed from the list of consumers.",
        "type": "object",
        "required": [
          "add_vote_hook"
        ],
        "properties": {
          "add_vote_hook": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Removed a consumer of vote hooks.",
        "type": "object",
        "required": [
          "remove_vote_hook"
        ],
        "properties": {
          "remove_vote_hook": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Admin": {
        "description": "Information about the CosmWasm level admin of a contract. Used in conjunction with `ModuleInstantiateInfo` to instantiate modules.",
        "oneOf": [
          {
            "description": "Set the admin to a specified address.",
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "object",
                "required": [
                  "addr"
                ],
                "properties": {
                  "addr": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sets the admin as the core module address.",
            "type": "object",
            "required": [
              "core_module"
            ],
            "properties": {
              "core_module": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "BankMsg": {
        "description": "The message types of the bank module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto",
        "oneOf": [
          {
            "description": "Sends native tokens from the contract to the given address.\n\nThis is translated to a [MsgSend](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto#L19-L28). `from_address` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "send"
            ],
            "properties": {
              "send": {
                "type": "object",
                "required": [
                  "amount",
                  "to_address"
                ],
                "properties": {
                  "amount": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  },
                  "to_address": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "This will burn the given coins from the contract's account. There is no Cosmos SDK message that performs this, but it can be done by calling the bank keeper. Important if a contract controls significant token supply that must be retired.",
            "type": "object",
            "required": [
              "burn"
            ],
            "properties": {
              "burn": {
                "type": "object",
                "required": [
                  "amount"
                ],
                "properties": {
                  "amount": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "CosmosMsg_for_Empty": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "bank"
            ],
            "properties": {
              "bank": {
                "$ref": "#/definitions/BankMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "custom"
            ],
            "properties": {
              "custom": {
                "$ref": "#/definitions/Empty"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "staking"
            ],
            "properties": {
              "staking": {
                "$ref": "#/definitions/StakingMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "distribution"
            ],
            "properties": {
              "distribution": {
                "$ref": "#/definitions/DistributionMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "A Stargate message encoded the same way as a protobuf [Any](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/any.proto). This is the same structure as messages in `TxBody` from [ADR-020](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-020-protobuf-transaction-encoding.md)",
            "type": "object",
            "required": [
              "stargate"
            ],
            "properties": {
              "stargate": {
                "type": "object",
                "required": [
                  "type_url",
                  "value"
                ],
                "properties": {
                  "type_url": {
                    "type": "string"
                  },
                  "value": {
                    "$ref": "#/definitions/Binary"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "ibc"
            ],
            "properties": {
              "ibc": {
                "$ref": "#/definitions/IbcMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "wasm"
            ],
            "properties": {
              "wasm": {
                "$ref": "#/definitions/WasmMsg"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "gov"
            ],
            "properties": {
              "gov": {
                "$ref": "#/definitions/GovMsg"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "DistributionMsg": {
        "description": "The message types of the distribution module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto",
        "oneOf": [
          {
            "description": "This is translated to a [MsgSetWithdrawAddress](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L29-L37). `delegator_address` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "set_withdraw_address"
            ],
            "properties": {
              "set_withdraw_address": {
                "type": "object",
                "required": [
                  "address"
                ],
                "properties": {
                  "address": {
                    "description": "The `withdraw_address`",
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "This is translated to a [[MsgWithdrawDelegatorReward](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L42-L50). `delegator_address` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "withdraw_delegator_reward"
            ],
            "properties": {
              "withdraw_delegator_reward": {
                "type": "object",
                "required": [
                  "validator"
                ],
                "properties": {
                  "validator": {
                    "description": "The `validator_address`",
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Duration": {
        "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "height"
            ],
            "properties": {
              "height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Time in seconds",
            "type": "object",
            "required": [
              "time"
            ],
            "properties": {
              "time": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Empty": {
        "description": "An empty struct that serves as a placeholder in different places, such as contracts that don't set a custom message.\n\nIt is designed to be expressable in correct JSON and JSON Schema but contains no meaningful data. Previously we used enums without cases, but those cannot represented as valid JSON Schema (https://github.com/CosmWasm/cosmwasm/issues/451)",
        "type": "object"
      },
      "GovMsg": {
        "description": "This message type allows the contract interact with the [x/gov] module in order to cast votes.\n\n[x/gov]: https://github.com/cosmos/cosmos-sdk/tree/v0.45.12/x/gov\n\n## Examples\n\nCast a simple vote:\n\n``` # use cosmwasm_std::{ #     HexBinary, #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo, #     Response, QueryResponse, # }; # type ExecuteMsg = (); use cosmwasm_std::{GovMsg, VoteOption};\n\n#[entry_point] pub fn execute( deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg, ) -> Result<Response, StdError> { // ... Ok(Response::new().add_message(GovMsg::Vote { proposal_id: 4, vote: VoteOption::Yes, })) } ```\n\nCast a weighted vote:\n\n``` # use cosmwasm_std::{ #     HexBinary, #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo, #     Response, QueryResponse, # }; # type ExecuteMsg = (); # #[cfg(feature = \"cosmwasm_1_2\")] use cosmwasm_std::{Decimal, GovMsg, VoteOption, WeightedVoteOption};\n\n# #[cfg(feature = \"cosmwasm_1_2\")] #[entry_point] pub fn execute( deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg, ) -> Result<Response, StdError> { // ... Ok(Response::new().add_message(GovMsg::VoteWeighted { proposal_id: 4, options: vec![ WeightedVoteOption { option: VoteOption::Yes, weight: Decimal::percent(65), }, WeightedVoteOption { option: VoteOption::Abstain, weight: Decimal::percent(35), }, ], })) } ```",
        "oneOf": [
          {
            "description": "This maps directly to [MsgVote](https://github.com/cosmos/cosmos-sdk/blob/v0.42.5/proto/cosmos/gov/v1beta1/tx.proto#L46-L56) in the Cosmos SDK with voter set to the contract address.",
            "type": "object",
            "required": [
              "vote"
            ],
            "properties": {
              "vote": {
                "type": "object",
                "required": [
                  "proposal_id",
                  "vote"
                ],
                "properties": {
                  "proposal_id": {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  },
                  "vote": {
                    "description": "The vote option.\n\nThis should be called \"option\" for consistency with Cosmos SDK. Sorry for that. See <https://github.com/CosmWasm/cosmwasm/issues/1571>.",
                    "allOf": [
                      {
                        "$ref": "#/definitions/VoteOption"
                      }
                    ]
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "This maps directly to [MsgVoteWeighted](https://github.com/cosmos/cosmos-sdk/blob/v0.45.8/proto/cosmos/gov/v1beta1/tx.proto#L66-L78) in the Cosmos SDK with voter set to the contract address.",
            "type": "object",
            "required": [
              "vote_weighted"
            ],
            "properties": {
              "vote_weighted": {
                "type": "object",
                "required": [
                  "options",
                  "proposal_id"
                ],
                "properties": {
                  "options": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/WeightedVoteOption"
                    }
                  },
                  "proposal_id": {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "IbcMsg": {
        "description": "These are messages in the IBC lifecycle. Only usable by IBC-enabled contracts (contracts that directly speak the IBC protocol via 6 entry points)",
        "oneOf": [
          {
            "description": "Sends bank tokens owned by the contract to the given address on another chain. The channel must already be established between the ibctransfer module on this chain and a matching module on the remote chain. We cannot select the port_id, this is whatever the local chain has bound the ibctransfer module to.",
            "type": "object",
            "required": [
              "transfer"
            ],
            "properties": {
              "transfer": {
                "type": "object",
                "required": [
                  "amount",
                  "channel_id",
                  "timeout",
                  "to_address"
                ],
                "properties": {
                  "amount": {
                    "description": "packet data only supports one coin https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/applications/transfer/v1/transfer.proto#L11-L20",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Coin"
                      }
                    ]
                  },
                  "channel_id": {
                    "description": "existing channel to send the tokens over",
                    "type": "string"
                  },
                  "timeout": {
                    "description": "when packet times out, measured on remote chain",
                    "allOf": [
                      {
                        "$ref": "#/definitions/IbcTimeout"
                      }
                    ]
                  },
                  "to_address": {
                    "description": "address on the remote chain to receive these tokens",
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sends an IBC packet with given data over the existing channel. Data should be encoded in a format defined by the channel version, and the module on the other side should know how to parse this.",
            "type": "object",
            "required": [
              "send_packet"
            ],
            "properties": {
              "send_packet": {
                "type": "object",
                "required": [
                  "channel_id",
                  "data",
                  "timeout"
                ],
                "properties": {
                  "channel_id": {
                    "type": "string"
                  },
                  "data": {
                    "$ref": "#/definitions/Binary"
                  },
                  "timeout": {
                    "description": "when packet times out, measured on remote chain",
                    "allOf": [
                      {
                        "$ref": "#/definitions/IbcTimeout"
                      }
                    ]
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "This will close an existing channel that is owned by this contract. Port is auto-assigned to the contract's IBC port",
            "type": "object",
            "required": [
              "close_channel"
            ],
            "properties": {
              "close_channel": {
                "type": "object",
                "required": [
                  "channel_id"
                ],
                "properties": {
                  "channel_id": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "IbcTimeout": {
        "description": "In IBC each package must set at least one type of timeout: the timestamp or the block height. Using this rather complex enum instead of two timeout fields we ensure that at least one timeout is set.",
        "type": "object",
        "properties": {
          "block": {
            "anyOf": [
              {
                "$ref": "#/definitions/IbcTimeoutBlock"
              },
              {
                "type": "null"
              }
            ]
          },
          "timestamp": {
            "anyOf": [
              {
                "$ref": "#/definitions/Timestamp"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "IbcTimeoutBlock": {
        "description": "IBCTimeoutHeight Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients. Ordering is (revision_number, timeout_height)",
        "type": "object",
        "required": [
          "height",
          "revision"
        ],
        "properties": {
          "height": {
            "description": "block height after which the packet times out. the height within the given revision",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "revision": {
            "description": "the version that the client is currently on (e.g. after resetting the chain this could increment 1 as height drops to 0)",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        }
      },
      "ModuleInstantiateInfo": {
        "description": "Information needed to instantiate a module.",
        "type": "object",
        "required": [
          "code_id",
          "funds",
          "label",
          "msg"
        ],
        "properties": {
          "admin": {
            "description": "CosmWasm level admin of the instantiated contract. See: <https://docs.cosmwasm.com/docs/1.0/smart-contracts/migration>",
            "anyOf": [
              {
                "$ref": "#/definitions/Admin"
              },
              {
                "type": "null"
              }
            ]
          },
          "code_id": {
            "description": "Code ID of the contract to be instantiated.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "funds": {
            "description": "Funds to be sent to the instantiated contract.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Coin"
            }
          },
          "label": {
            "description": "Label for the instantiated contract.",
            "type": "string"
          },
          "msg": {
            "description": "Instantiate message to be used to create the contract.",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "PercentageThreshold": {
        "description": "A percentage of voting power that must vote yes for a proposal to pass. An example of why this is needed:\n\nIf a user specifies a 60% passing threshold, and there are 10 voters they likely expect that proposal to pass when there are 6 yes votes. This implies that the condition for passing should be `vote_weights >= total_votes * threshold`.\n\nWith this in mind, how should a user specify that they would like proposals to pass if the majority of voters choose yes? Selecting a 50% passing threshold with those rules doesn't properly cover that case as 5 voters voting yes out of 10 would pass the proposal. Selecting 50.0001% or or some variation of that also does not work as a very small yes vote which technically makes the majority yes may not reach that threshold.\n\nTo handle these cases we provide both a majority and percent option for all percentages. If majority is selected passing will be determined by `yes > total_votes * 0.5`. If percent is selected passing is determined by `yes >= total_votes * percent`.\n\nIn both of these cases a proposal with only abstain votes must fail. This requires a special case passing logic.",
        "oneOf": [
          {
            "description": "The majority of voters must vote yes for the proposal to pass.",
            "type": "object",
            "required": [
              "majority"
            ],
            "properties": {
              "majority": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "A percentage of voting power >= percent must vote yes for the proposal to pass.",
            "type": "object",
            "required": [
              "percent"
            ],
            "properties": {
              "percent": {
                "$ref": "#/definitions/Decimal"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "PreProposeInfo": {
        "oneOf": [
          {
            "description": "Anyone may create a proposal free of charge.",
            "type": "object",
            "required": [
              "anyone_may_propose"
            ],
            "properties": {
              "anyone_may_propose": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "The module specified in INFO has exclusive rights to proposal creation.",
            "type": "object",
            "required": [
              "module_may_propose"
            ],
            "properties": {
              "module_may_propose": {
                "type": "object",
                "required": [
                  "info"
                ],
                "properties": {
                  "info": {
                    "$ref": "#/definitions/ModuleInstantiateInfo"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "SingleChoiceAutoVote": {
        "type": "object",
        "required": [
          "vote"
        ],
        "properties": {
          "rationale": {
            "description": "An optional rationale for why this vote was cast. This can be updated, set, or removed later by the address casting the vote.",
            "type": [
              "string",
              "null"
            ]
          },
          "vote": {
            "description": "The proposer's position on the proposal.",
            "allOf": [
              {
                "$ref": "#/definitions/Vote"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "SingleChoiceProposeMsg": {
        "description": "The contents of a message to create a proposal in the single choice proposal module.\n\nWe break this type out of `ExecuteMsg` because we want pre-propose modules that interact with this contract to be able to get type checking on their propose messages.\n\nWe move this type to this package so that pre-propose modules can import it without importing dao-proposal-single with the library feature which (as it is not additive) cause the execute exports to not be included in wasm builds.",
        "type": "object",
        "required": [
          "description",
          "msgs",
          "title"
        ],
        "properties": {
          "description": {
            "description": "A description of the proposal.",
            "type": "string"
          },
          "msgs": {
            "description": "The messages that should be executed in response to this proposal passing.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/CosmosMsg_for_Empty"
            }
          },
          "proposer": {
            "description": "The address creating the proposal. If no pre-propose module is attached to this module this must always be None as the proposer is the sender of the propose message. If a pre-propose module is attached, this must be Some and will set the proposer of the proposal it creates.",
            "type": [
              "string",
              "null"
            ]
          },
          "title": {
            "description": "The title of the proposal.",
            "type": "string"
          },
          "vote": {
            "description": "An optional vote cast by the proposer.",
            "anyOf": [
              {
                "$ref": "#/definitions/SingleChoiceAutoVote"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "StakingMsg": {
        "description": "The message types of the staking module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto",
        "oneOf": [
          {
            "description": "This is translated to a [MsgDelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L81-L90). `delegator_address` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "delegate"
            ],
            "properties": {
              "delegate": {
                "type": "object",
                "required": [
                  "amount",
                  "validator"
                ],
                "properties": {
                  "amount": {
                    "$ref": "#/definitions/Coin"
                  },
                  "validator": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "This is translated to a [MsgUndelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L112-L121). `delegator_address` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "undelegate"
            ],
            "properties": {
              "undelegate": {
                "type": "object",
                "required": [
                  "amount",
                  "validator"
                ],
                "properties": {
                  "amount": {
                    "$ref": "#/definitions/Coin"
                  },
                  "validator": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "This is translated to a [MsgBeginRedelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L95-L105). `delegator_address` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "redelegate"
            ],
            "properties": {
              "redelegate": {
                "type": "object",
                "required": [
                  "amount",
                  "dst_validator",
                  "src_validator"
                ],
                "properties": {
                  "amount": {
                    "$ref": "#/definitions/Coin"
                  },
                  "dst_validator": {
                    "type": "string"
                  },
                  "src_validator": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Threshold": {
        "description": "The ways a proposal may reach its passing / failing threshold.",
        "oneOf": [
          {
            "description": "Declares a percentage of the total weight that must cast Yes votes in order for a proposal to pass.  See `ThresholdResponse::AbsolutePercentage` in the cw3 spec for details.",
            "type": "object",
            "required": [
              "absolute_percentage"
            ],
            "properties": {
              "absolute_percentage": {
                "type": "object",
                "required": [
                  "percentage"
                ],
                "properties": {
                  "percentage": {
                    "$ref": "#/definitions/PercentageThreshold"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Declares a `quorum` of the total votes that must participate in the election in order for the vote to be considered at all. See `ThresholdResponse::ThresholdQuorum` in the cw3 spec for details.",
            "type": "object",
            "required": [
              "threshold_quorum"
            ],
            "properties": {
              "threshold_quorum": {
                "type": "object",
                "required": [
                  "quorum",
                  "threshold"
                ],
                "properties": {
                  "quorum": {
                    "$ref": "#/definitions/PercentageThreshold"
                  },
                  "threshold": {
                    "$ref": "#/definitions/PercentageThreshold"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "An absolute number of votes needed for something to cross the threshold. Useful for multisig style voting.",
            "type": "object",
            "required": [
              "absolute_count"
            ],
            "properties": {
              "absolute_count": {
                "type": "object",
                "required": [
                  "threshold"
                ],
                "properties": {
                  "threshold": {
                    "$ref": "#/definitions/Uint128"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      },
      "VetoConfig": {
        "type": "object",
        "required": [
          "early_execute",
          "timelock_duration",
          "veto_before_passed",
          "vetoer"
        ],
        "properties": {
          "early_execute": {
            "description": "Whether or not the vetoer can execute a proposal early before the timelock duration has expired",
            "type": "boolean"
          },
          "timelock_duration": {
            "description": "The time duration to lock a proposal for after its expiration to allow the vetoer to veto.",
            "allOf": [
              {
                "$ref": "#/definitions/Duration"
              }
            ]
          },
          "veto_before_passed": {
            "description": "Whether or not the vetoer can veto a proposal before it passes.",
            "type": "boolean"
          },
          "vetoer": {
            "description": "The address able to veto proposals.",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Vote": {
        "oneOf": [
          {
            "description": "Marks support for the proposal.",
            "type": "string",
            "enum": [
              "yes"
            ]
          },
          {
            "description": "Marks opposition to the proposal.",
            "type": "string",
            "enum": [
              "no"
            ]
          },
          {
            "description": "Marks participation but does not count towards the ratio of support / opposed.",
            "type": "string",
            "enum": [
              "abstain"
            ]
          }
        ]
      },
      "VoteOption": {
        "type": "string",
        "enum": [
          "yes",
          "no",
          "abstain",
          "no_with_veto"
        ]
      },
      "WasmMsg": {
        "description": "The message types of the wasm module.\n\nSee https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto",
        "oneOf": [
          {
            "description": "Dispatches a call to another contract at a known address (with known ABI).\n\nThis is translated to a [MsgExecuteContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L68-L78). `sender` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "execute"
            ],
            "properties": {
              "execute": {
                "type": "object",
                "required": [
                  "contract_addr",
                  "funds",
                  "msg"
                ],
                "properties": {
                  "contract_addr": {
                    "type": "string"
                  },
                  "funds": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  },
                  "msg": {
                    "description": "msg is the json-encoded ExecuteMsg struct (as raw Binary)",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      }
                    ]
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Instantiates a new contracts from previously uploaded Wasm code.\n\nThe contract address is non-predictable. But it is guaranteed that when emitting the same Instantiate message multiple times, multiple instances on different addresses will be generated. See also Instantiate2.\n\nThis is translated to a [MsgInstantiateContract](https://github.com/CosmWasm/wasmd/blob/v0.29.2/proto/cosmwasm/wasm/v1/tx.proto#L53-L71). `sender` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "instantiate"
            ],
            "properties": {
              "instantiate": {
                "type": "object",
                "required": [
                  "code_id",
                  "funds",
                  "label",
                  "msg"
                ],
                "properties": {
                  "admin": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "code_id": {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  },
                  "funds": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  },
                  "label": {
                    "description": "A human-readable label for the contract.\n\nValid values should: - not be empty - not be bigger than 128 bytes (or some chain-specific limit) - not start / end with whitespace",
                    "type": "string"
                  },
                  "msg": {
                    "description": "msg is the JSON-encoded InstantiateMsg struct (as raw Binary)",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      }
                    ]
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Instantiates a new contracts from previously uploaded Wasm code using a predictable address derivation algorithm implemented in [`cosmwasm_std::instantiate2_address`].\n\nThis is translated to a [MsgInstantiateContract2](https://github.com/CosmWasm/wasmd/blob/v0.29.2/proto/cosmwasm/wasm/v1/tx.proto#L73-L96). `sender` is automatically filled with the current contract's address. `fix_msg` is automatically set to false.",
            "type": "object",
            "required": [
              "instantiate2"
            ],
            "properties": {
              "instantiate2": {
                "type": "object",
                "required": [
                  "code_id",
                  "funds",
                  "label",
                  "msg",
                  "salt"
                ],
                "properties": {
                  "admin": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "code_id": {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  },
                  "funds": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  },
                  "label": {
                    "description": "A human-readable label for the contract.\n\nValid values should: - not be empty - not be bigger than 128 bytes (or some chain-specific limit) - not start / end with whitespace",
                    "type": "string"
                  },
                  "msg": {
                    "description": "msg is the JSON-encoded InstantiateMsg struct (as raw Binary)",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      }
                    ]
                  },
                  "salt": {
                    "$ref": "#/definitions/Binary"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Migrates a given contracts to use new wasm code. Passes a MigrateMsg to allow us to customize behavior.\n\nOnly the contract admin (as defined in wasmd), if any, is able to make this call.\n\nThis is translated to a [MsgMigrateContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L86-L96). `sender` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "migrate"
            ],
            "properties": {
              "migrate": {
                "type": "object",
                "required": [
                  "contract_addr",
                  "msg",
                  "new_code_id"
                ],
                "properties": {
                  "contract_addr": {
                    "type": "string"
                  },
                  "msg": {
                    "description": "msg is the json-encoded MigrateMsg struct that will be passed to the new code",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      }
                    ]
                  },
                  "new_code_id": {
                    "description": "the code_id of the new logic to place in the given contract",
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sets a new admin (for migrate) on the given contract. Fails if this contract is not currently admin of the target contract.",
            "type": "object",
            "required": [
              "update_admin"
            ],
            "properties": {
              "update_admin": {
                "type": "object",
                "required": [
                  "admin",
                  "contract_addr"
                ],
                "properties": {
                  "admin": {
                    "type": "string"
                  },
                  "contract_addr": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Clears the admin on the given contract, so no more migration possible. Fails if this contract is not currently admin of the target contract.",
            "type": "object",
            "required": [
              "clear_admin"
            ],
            "properties": {
              "clear_admin": {
                "type": "object",
                "required": [
                  "contract_addr"
                ],
                "properties": {
                  "contract_addr": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "WeightedVoteOption": {
        "type": "object",
        "required": [
          "option",
          "weight"
        ],
        "properties": {
          "option": {
            "$ref": "#/definitions/VoteOption"
          },
          "weight": {
            "$ref": "#/definitions/Decimal"
          }
        }
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Gets the proposal module's config.",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets information about a proposal.",
        "type": "object",
        "required": [
          "proposal"
        ],
        "properties": {
          "proposal": {
            "type": "object",
            "required": [
              "proposal_id"
            ],
            "properties": {
              "proposal_id": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Lists all the proposals that have been cast in this module.",
        "type": "object",
        "required": [
          "list_proposals"
        ],
        "properties": {
          "list_proposals": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "The maximum number of proposals to return as part of this query. If no limit is set a max of 30 proposals will be returned.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "start_after": {
                "description": "The proposal ID to start listing proposals after. For example, if this is set to 2 proposals with IDs 3 and higher will be returned.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Lists all of the proposals that have been cast in this module in decending order of proposal ID.",
        "type": "object",
        "required": [
          "reverse_proposals"
        ],
        "properties": {
          "reverse_proposals": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "The maximum number of proposals to return as part of this query. If no limit is set a max of 30 proposals will be returned.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "start_before": {
                "description": "The proposal ID to start listing proposals before. For example, if this is set to 6 proposals with IDs 5 and lower will be returned.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns a voters position on a propsal.",
        "type": "object",
        "required": [
          "get_vote"
        ],
        "properties": {
          "get_vote": {
            "type": "object",
            "required": [
              "proposal_id",
              "voter"
            ],
            "properties": {
              "proposal_id": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "voter": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Lists all of the votes that have been cast on a proposal.",
        "type": "object",
        "required": [
          "list_votes"
        ],
        "properties": {
          "list_votes": {
            "type": "object",
            "required": [
              "proposal_id"
            ],
            "properties": {
              "limit": {
                "description": "The maximum number of votes to return in response to this query. If no limit is specified a max of 30 are returned.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "proposal_id": {
                "description": "The proposal to list the votes of.",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "start_after": {
                "description": "The voter to start listing votes after. Ordering is done alphabetically.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the number of proposals that have been created in this module.",
        "type": "object",
        "required": [
          "proposal_count"
        ],
        "properties": {
          "proposal_count": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the current proposal creation policy for this module.",
        "type": "object",
        "required": [
          "proposal_creation_policy"
        ],
        "properties": {
          "proposal_creation_policy": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the address of the delegation module associated with this proposal module (if any).",
        "type": "object",
        "required": [
          "delegation_module"
        ],
        "properties": {
          "delegation_module": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Lists all of the consumers of proposal hooks for this module.",
        "type": "object",
        "required": [
          "proposal_hooks"
        ],
        "properties": {
          "proposal_hooks": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Lists all of the consumers of vote hooks for this module.",
        "type": "object",
        "required": [
          "vote_hooks"
        ],
        "properties": {
          "vote_hooks": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the address of the DAO this module belongs to",
        "type": "object",
        "required": [
          "dao"
        ],
        "properties": {
          "dao": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns contract version info",
        "type": "object",
        "required": [
          "info"
        ],
        "properties": {
          "info": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the proposal ID that will be assigned to the next proposal created.",
        "type": "object",
        "required": [
          "next_proposal_id"
        ],
        "properties": {
          "next_proposal_id": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "from_v1"
        ],
        "properties": {
          "from_v1": {
            "type": "object",
            "required": [
              "close_proposal_on_execution_failure",
              "pre_propose_info"
            ],
            "properties": {
              "close_proposal_on_execution_failure": {
                "description": "This field was not present in DAO DAO v1. To migrate, a value must be specified.\n\nIf set to true proposals will be closed if their execution fails. Otherwise, proposals will remain open after execution failure. For example, with this enabled a proposal to send 5 tokens out of a DAO's treasury with 4 tokens would be closed when it is executed. With this disabled, that same proposal would remain open until the DAO's treasury was large enough for it to be executed.",
                "type": "boolean"
              },
              "pre_propose_info": {
                "description": "This field was not present in DAO DAO v1. To migrate, a value must be specified.\n\nThis contains information about how a pre-propose module may be configured. If set to \"AnyoneMayPropose\", there will be no pre-propose module and consequently, no deposit or membership checks when submitting a proposal. The \"ModuleMayPropose\" option allows for instantiating a prepropose module which will handle deposit verification and return logic.",
                "allOf": [
                  {
                    "$ref": "#/definitions/PreProposeInfo"
                  }
                ]
              },
              "veto": {
                "description": "This field was not present in DAO DAO v1. To migrate, a value must be specified.\n\noptional configuration for veto feature",
                "anyOf": [
                  {
                    "$ref": "#/definitions/VetoConfig"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "from_compatible"
        ],
        "properties": {
          "from_compatible": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Admin": {
        "description": "Information about the CosmWasm level admin of a contract. Used in conjunction with `ModuleInstantiateInfo` to instantiate modules.",
        "oneOf": [
          {
            "description": "Set the admin to a specified address.",
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "object",
                "required": [
                  "addr"
                ],
                "properties": {
                  "addr": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sets the admin as the core module address.",
            "type": "object",
            "required": [
              "core_module"
            ],
            "properties": {
              "core_module": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Duration": {
        "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "height"
            ],
            "properties": {
              "height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Time in seconds",
            "type": "object",
            "required": [
              "time"
            ],
            "properties": {
              "time": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ModuleInstantiateInfo": {
        "description": "Information needed to instantiate a module.",
        "type": "object",
        "required": [
          "code_id",
          "funds",
          "label",
          "msg"
        ],
        "properties": {
          "admin": {
            "description": "CosmWasm level admin of the instantiated contract. See: <https://docs.cosmwasm.com/docs/1.0/smart-contracts/migration>",
            "anyOf": [
              {
                "$ref": "#/definitions/Admin"
              },
              {
                "type": "null"
              }
            ]
          },
          "code_id": {
            "description": "Code ID of the contract to be instantiated.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "funds": {
            "description": "Funds to be sent to the instantiated contract.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Coin"
            }
          },
          "label": {
            "description": "Label for the instantiated contract.",
            "type": "string"
          },
          "msg": {
            "description": "Instantiate message to be used to create the contract.",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "PreProposeInfo": {
        "oneOf": [
          {
            "description": "Anyone may create a proposal free of charge.",
            "type": "object",
            "required": [
              "anyone_may_propose"
            ],
            "properties": {
              "anyone_may_propose": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "The module specified in INFO has exclusive rights to proposal creation.",
            "type": "object",
            "required": [
              "module_may_propose"
            ],
            "properties": {
              "module_may_propose": {
                "type": "object",
                "required": [
                  "info"
                ],
                "properties": {
                  "info": {
                    "$ref": "#/definitions/ModuleInstantiateInfo"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "VetoConfig": {
        "type": "object",
        "required": [
          "early_execute",
          "timelock_duration",
          "veto_before_passed",
          "vetoer"
        ],
        "properties": {
          "early_execute": {
            "description": "Whether or not the vetoer can execute a proposal early before the timelock duration has expired",
            "type": "boolean"
          },
          "timelock_duration": {
            "description": "The time duration to lock a proposal for after its expiration to allow the vetoer to veto.",
            "allOf": [
              {
                "$ref": "#/definitions/Duration"
              }
            ]
          },
          "veto_before_passed": {
            "description": "Whether or not the vetoer can veto a proposal before it passes.",
            "type": "boolean"
          },
          "vetoer": {
            "description": "The address able to veto proposals.",
            "type": "string"
          }
        },
        "additionalProperties": false
      }
    }
  },
  "sudo": null,
  "responses": {
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config",
      "description": "The governance module's configuration.",
      "type": "object",
      "required": [
        "allow_revoting",
        "close_proposal_on_execution_failure",
        "dao",
        "max_voting_period",
        "only_members_execute",
        "threshold"
      ],
      "properties": {
        "allow_revoting": {
          "description": "Allows changing votes before the proposal expires. If this is enabled proposals will not be able to complete early as final vote information is not known until the time of proposal expiration.",
          "type": "boolean"
        },
        "close_proposal_on_execution_failure": {
          "description": "If set to true proposals will be closed if their execution fails. Otherwise, proposals will remain open after execution failure. For example, with this enabled a proposal to send 5 tokens out of a DAO's treasury with 4 tokens would be closed when it is executed. With this disabled, that same proposal would remain open until the DAO's treasury was large enough for it to be executed.",
          "type": "boolean"
        },
        "dao": {
          "description": "The address of the DAO that this governance module is associated with.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "max_voting_period": {
          "description": "The default maximum amount of time a proposal may be voted on before expiring.",
          "allOf": [
            {
              "$ref": "#/definitions/Duration"
            }
          ]
        },
        "min_voting_period": {
          "description": "The minimum amount of time a proposal must be open before passing. A proposal may fail before this amount of time has elapsed, but it will not pass. This can be useful for preventing governance attacks wherein an attacker aquires a large number of tokens and forces a proposal through.",
          "anyOf": [
            {
              "$ref": "#/definitions/Duration"
            },
            {
              "type": "null"
            }
          ]
        },
        "only_members_execute": {
          "description": "If set to true only members may execute passed proposals. Otherwise, any address may execute a passed proposal.",
          "type": "boolean"
        },
        "threshold": {
          "description": "The threshold a proposal must reach to complete.",
          "allOf": [
            {
              "$ref": "#/definitions/Threshold"
            }
          ]
        },
        "veto": {
          "description": "Optional veto configuration. If set to `None`, veto option is disabled. Otherwise contains the configuration for veto flow.",
          "anyOf": [
            {
              "$ref": "#/definitions/VetoConfig"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Duration": {
          "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "height"
              ],
              "properties": {
                "height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Time in seconds",
              "type": "object",
              "required": [
                "time"
              ],
              "properties": {
                "time": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PercentageThreshold": {
          "description": "A percentage of voting power that must vote yes for a proposal to pass. An example of why this is needed:\n\nIf a user specifies a 60% passing threshold, and there are 10 voters they likely expect that proposal to pass when there are 6 yes votes. This implies that the condition for passing should be `vote_weights >= total_votes * threshold`.\n\nWith this in mind, how should a user specify that they would like proposals to pass if the majority of voters choose yes? Selecting a 50% passing threshold with those rules doesn't properly cover that case as 5 voters voting yes out of 10 would pass the proposal. Selecting 50.0001% or or some variation of that also does not work as a very small yes vote which technically makes the majority yes may not reach that threshold.\n\nTo handle these cases we provide both a majority and percent option for all percentages. If majority is selected passing will be determined by `yes > total_votes * 0.5`. If percent is selected passing is determined by `yes >= total_votes * percent`.\n\nIn both of these cases a proposal with only abstain votes must fail. This requires a special case passing logic.",
          "oneOf": [
            {
              "description": "The majority of voters must vote yes for the proposal to pass.",
              "type": "object",
              "required": [
                "majority"
              ],
              "properties": {
                "majority": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "A percentage of voting power >= percent must vote yes for the proposal to pass.",
              "type": "object",
              "required": [
                "percent"
              ],
              "properties": {
                "percent": {
                  "$ref": "#/definitions/Decimal"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Threshold": {
          "description": "The ways a proposal may reach its passing / failing threshold.",
          "oneOf": [
            {
              "description": "Declares a percentage of the total weight that must cast Yes votes in order for a proposal to pass.  See `ThresholdResponse::AbsolutePercentage` in the cw3 spec for details.",
              "type": "object",
              "required": [
                "absolute_percentage"
              ],
              "properties": {
                "absolute_percentage": {
                  "type": "object",
                  "required": [
                    "percentage"
                  ],
                  "properties": {
                    "percentage": {
                      "$ref": "#/definitions/PercentageThreshold"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Declares a `quorum` of the total votes that must participate in the election in order for the vote to be considered at all. See `ThresholdResponse::ThresholdQuorum` in the cw3 spec for details.",
              "type": "object",
              "required": [
                "threshold_quorum"
              ],
              "properties": {
                "threshold_quorum": {
                  "type": "object",
                  "required": [
                    "quorum",
                    "threshold"
                  ],
                  "properties": {
                    "quorum": {
                      "$ref": "#/definitions/PercentageThreshold"
                    },
                    "threshold": {
                      "$ref": "#/definitions/PercentageThreshold"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "An absolute number of votes needed for something to cross the threshold. Useful for multisig style voting.",
              "type": "object",
              "required": [
                "absolute_count"
              ],
              "properties": {
                "absolute_count": {
                  "type": "object",
                  "required": [
                    "threshold"
                  ],
                  "properties": {
                    "threshold": {
                      "$ref": "#/definitions/Uint128"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "VetoConfig": {
          "type": "object",
          "required": [
            "early_execute",
            "timelock_duration",
            "veto_before_passed",
            "vetoer"
          ],
          "properties": {
            "early_execute": {
              "description": "Whether or not the vetoer can execute a proposal early before the timelock duration has expired",
              "type": "boolean"
            },
            "timelock_duration": {
              "description": "The time duration to lock a proposal for after its expiration to allow the vetoer to veto.",
              "allOf": [
                {
                  "$ref": "#/definitions/Duration"
                }
              ]
            },
            "veto_before_passed": {
              "description": "Whether or not the vetoer can veto a proposal before it passes.",
              "type": "boolean"
            },
            "vetoer": {
              "description": "The address able to veto proposals.",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      }
    },
    "dao": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "delegation_module": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_Addr",
      "anyOf": [
        {
          "$ref": "#/definitions/Addr"
        },
        {
          "type": "null"
        }
      ],
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "get_vote": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VoteResponse",
      "description": "Information about a vote.",
      "type": "object",
      "properties": {
        "vote": {
          "description": "None if no such vote, Some otherwise.",
          "anyOf": [
            {
              "$ref": "#/definitions/VoteInfo"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Vote": {
          "oneOf": [
            {
              "description": "Marks support for the proposal.",
              "type": "string",
              "enum": [
                "yes"
              ]
            },
            {
              "description": "Marks opposition to the proposal.",
              "type": "string",
              "enum": [
                "no"
              ]
            },
            {
              "description": "Marks participation but does not count towards the ratio of support / opposed.",
              "type": "string",
              "enum": [
                "abstain"
              ]
            }
          ]
        },
        "VoteInfo": {
          "description": "Information about a vote that was cast.",
          "type": "object",
          "required": [
            "power",
            "vote",
            "voter"
          ],
          "properties": {
            "power": {
              "description": "The voting power behind the vote.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "rationale": {
              "description": "Address-specified rationale for the vote.",
              "type": [
                "string",
                "null"
              ]
            },
            "vote": {
              "description": "Position on the vote.",
              "allOf": [
                {
                  "$ref": "#/definitions/Vote"
                }
              ]
            },
            "voter": {
              "description": "The address that voted.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            }
          },
          "additionalProperties": false
        }
      }
    },
    "info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "InfoResponse",
      "type": "object",
      "required": [
        "info"
      ],
      "properties": {
        "info": {
          "$ref": "#/definitions/ContractVersion"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "ContractVersion": {
          "type": "object",
          "required": [
            "contract",
            "version"
          ],
          "properties": {
            "contract": {
              "description": "contract is the crate name of the implementing contract, eg. `crate:cw20-base` we will use other prefixes for other languages, and their standard global namespacing",
              "type": "string"
            },
            "version": {
              "description": "version is any string that this implementation knows. It may be simple counter \"1\", \"2\". or semantic version on release tags \"v0.7.0\", or some custom feature flag list. the only code that needs to understand the version parsing is code that knows how to migrate from the given contract (and is tied to it's implementation somehow)",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      }
    },
    "list_proposals": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ProposalListResponse",
      "description": "A list of proposals returned by `ListProposals` and `ReverseProposals`.",
      "type": "object",
      "required": [
        "proposals"
      ],
      "properties": {
        "proposals": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ProposalResponse"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "BankMsg": {
          "description": "The message types of the bank module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto",
          "oneOf": [
            {
              "description": "Sends native tokens from the contract to the given address.\n\nThis is translated to a [MsgSend](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto#L19-L28). `from_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "send"
              ],
              "properties": {
                "send": {
                  "type": "object",
                  "required": [
                    "amount",
                    "to_address"
                  ],
                  "properties": {
                    "amount": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    },
                    "to_address": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This will burn the given coins from the contract's account. There is no Cosmos SDK message that performs this, but it can be done by calling the bank keeper. Important if a contract controls significant token supply that must be retired.",
              "type": "object",
              "required": [
                "burn"
              ],
              "properties": {
                "burn": {
                  "type": "object",
                  "required": [
                    "amount"
                  ],
                  "properties": {
                    "amount": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Binary": {
          "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "CosmosMsg_for_Empty": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "bank"
              ],
              "properties": {
                "bank": {
                  "$ref": "#/definitions/BankMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "custom"
              ],
              "properties": {
                "custom": {
                  "$ref": "#/definitions/Empty"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "staking"
              ],
              "properties": {
                "staking": {
                  "$ref": "#/definitions/StakingMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "distribution"
              ],
              "properties": {
                "distribution": {
                  "$ref": "#/definitions/DistributionMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "A Stargate message encoded the same way as a protobuf [Any](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/any.proto). This is the same structure as messages in `TxBody` from [ADR-020](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-020-protobuf-transaction-encoding.md)",
              "type": "object",
              "required": [
                "stargate"
              ],
              "properties": {
                "stargate": {
                  "type": "object",
                  "required": [
                    "type_url",
                    "value"
                  ],
                  "properties": {
                    "type_url": {
                      "type": "string"
                    },
                    "value": {
                      "$ref": "#/definitions/Binary"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "ibc"
              ],
              "properties": {
                "ibc": {
                  "$ref": "#/definitions/IbcMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "wasm"
              ],
              "properties": {
                "wasm": {
                  "$ref": "#/definitions/WasmMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "gov"
              ],
              "properties": {
                "gov": {
                  "$ref": "#/definitions/GovMsg"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "DistributionMsg": {
          "description": "The message types of the distribution module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto",
          "oneOf": [
            {
              "description": "This is translated to a [MsgSetWithdrawAddress](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L29-L37). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "set_withdraw_address"
              ],
              "properties": {
                "set_withdraw_address": {
                  "type": "object",
                  "required": [
                    "address"
                  ],
                  "properties": {
                    "address": {
                      "description": "The `withdraw_address`",
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This is translated to a [[MsgWithdrawDelegatorReward](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L42-L50). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "withdraw_delegator_reward"
              ],
              "properties": {
                "withdraw_delegator_reward": {
                  "type": "object",
                  "required": [
                    "validator"
                  ],
                  "properties": {
                    "validator": {
                      "description": "The `validator_address`",
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Duration": {
          "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "height"
              ],
              "properties": {
                "height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Time in seconds",
              "type": "object",
              "required": [
                "time"
              ],
              "properties": {
                "time": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Empty": {
          "description": "An empty struct that serves as a placeholder in different places, such as contracts that don't set a custom message.\n\nIt is designed to be expressable in correct JSON and JSON Schema but contains no meaningful data. Previously we used enums without cases, but those cannot represented as valid JSON Schema (https://github.com/CosmWasm/cosmwasm/issues/451)",
          "type": "object"
        },
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "GovMsg": {
          "description": "This message type allows the contract interact with the [x/gov] module in order to cast votes.\n\n[x/gov]: https://github.com/cosmos/cosmos-sdk/tree/v0.45.12/x/gov\n\n## Examples\n\nCast a simple vote:\n\n``` # use cosmwasm_std::{ #     HexBinary, #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo, #     Response, QueryResponse, # }; # type ExecuteMsg = (); use cosmwasm_std::{GovMsg, VoteOption};\n\n#[entry_point] pub fn execute( deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg, ) -> Result<Response, StdError> { // ... Ok(Response::new().add_message(GovMsg::Vote { proposal_id: 4, vote: VoteOption::Yes, })) } ```\n\nCast a weighted vote:\n\n``` # use cosmwasm_std::{ #     HexBinary, #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo, #     Response, QueryResponse, # }; # type ExecuteMsg = (); # #[cfg(feature = \"cosmwasm_1_2\")] use cosmwasm_std::{Decimal, GovMsg, VoteOption, WeightedVoteOption};\n\n# #[cfg(feature = \"cosmwasm_1_2\")] #[entry_point] pub fn execute( deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg, ) -> Result<Response, StdError> { // ... Ok(Response::new().add_message(GovMsg::VoteWeighted { proposal_id: 4, options: vec![ WeightedVoteOption { option: VoteOption::Yes, weight: Decimal::percent(65), }, WeightedVoteOption { option: VoteOption::Abstain, weight: Decimal::percent(35), }, ], })) } ```",
          "oneOf": [
            {
              "description": "This maps directly to [MsgVote](https://github.com/cosmos/cosmos-sdk/blob/v0.42.5/proto/cosmos/gov/v1beta1/tx.proto#L46-L56) in the Cosmos SDK with voter set to the contract address.",
              "type": "object",
              "required": [
                "vote"
              ],
              "properties": {
                "vote": {
                  "type": "object",
                  "required": [
                    "proposal_id",
                    "vote"
                  ],
                  "properties": {
                    "proposal_id": {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "vote": {
                      "description": "The vote option.\n\nThis should be called \"option\" for consistency with Cosmos SDK. Sorry for that. See <https://github.com/CosmWasm/cosmwasm/issues/1571>.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/VoteOption"
                        }
                      ]
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This maps directly to [MsgVoteWeighted](https://github.com/cosmos/cosmos-sdk/blob/v0.45.8/proto/cosmos/gov/v1beta1/tx.proto#L66-L78) in the Cosmos SDK with voter set to the contract address.",
              "type": "object",
              "required": [
                "vote_weighted"
              ],
              "properties": {
                "vote_weighted": {
                  "type": "object",
                  "required": [
                    "options",
                    "proposal_id"
                  ],
                  "properties": {
                    "options": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/WeightedVoteOption"
                      }
                    },
                    "proposal_id": {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "IbcMsg": {
          "description": "These are messages in the IBC lifecycle. Only usable by IBC-enabled contracts (contracts that directly speak the IBC protocol via 6 entry points)",
          "oneOf": [
            {
              "description": "Sends bank tokens owned by the contract to the given address on another chain. The channel must already be established between the ibctransfer module on this chain and a matching module on the remote chain. We cannot select the port_id, this is whatever the local chain has bound the ibctransfer module to.",
              "type": "object",
              "required": [
                "transfer"
              ],
              "properties": {
                "transfer": {
                  "type": "object",
                  "required": [
                    "amount",
                    "channel_id",
                    "timeout",
                    "to_address"
                  ],
                  "properties": {
                    "amount": {
                      "description": "packet data only supports one coin https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/applications/transfer/v1/transfer.proto#L11-L20",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "channel_id": {
                      "description": "existing channel to send the tokens over",
                      "type": "string"
                    },
                    "timeout": {
                      "description": "when packet times out, measured on remote chain",
                      "allOf": [
                        {
                          "$ref": "#/definitions/IbcTimeout"
                        }
                      ]
                    },
                    "to_address": {
                      "description": "address on the remote chain to receive these tokens",
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Sends an IBC packet with given data over the existing channel. Data should be encoded in a format defined by the channel version, and the module on the other side should know how to parse this.",
              "type": "object",
              "required": [
                "send_packet"
              ],
              "properties": {
                "send_packet": {
                  "type": "object",
                  "required": [
                    "channel_id",
                    "data",
                    "timeout"
                  ],
                  "properties": {
                    "channel_id": {
                      "type": "string"
                    },
                    "data": {
                      "$ref": "#/definitions/Binary"
                    },
                    "timeout": {
                      "description": "when packet times out, measured on remote chain",
                      "allOf": [
                        {
                          "$ref": "#/definitions/IbcTimeout"
                        }
                      ]
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This will close an existing channel that is owned by this contract. Port is auto-assigned to the contract's IBC port",
              "type": "object",
              "required": [
                "close_channel"
              ],
              "properties": {
                "close_channel": {
                  "type": "object",
                  "required": [
                    "channel_id"
                  ],
                  "properties": {
                    "channel_id": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "IbcTimeout": {
          "description": "In IBC each package must set at least one type of timeout: the timestamp or the block height. Using this rather complex enum instead of two timeout fields we ensure that at least one timeout is set.",
          "type": "object",
          "properties": {
            "block": {
              "anyOf": [
                {
                  "$ref": "#/definitions/IbcTimeoutBlock"
                },
                {
                  "type": "null"
                }
              ]
            },
            "timestamp": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        "IbcTimeoutBlock": {
          "description": "IBCTimeoutHeight Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients. Ordering is (revision_number, timeout_height)",
          "type": "object",
          "required": [
            "height",
            "revision"
          ],
          "properties": {
            "height": {
              "description": "block height after which the packet times out. the height within the given revision",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "revision": {
              "description": "the version that the client is currently on (e.g. after resetting the chain this could increment 1 as height drops to 0)",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "PercentageThreshold": {
          "description": "A percentage of voting power that must vote yes for a proposal to pass. An example of why this is needed:\n\nIf a user specifies a 60% passing threshold, and there are 10 voters they likely expect that proposal to pass when there are 6 yes votes. This implies that the condition for passing should be `vote_weights >= total_votes * threshold`.\n\nWith this in mind, how should a user specify that they would like proposals to pass if the majority of voters choose yes? Selecting a 50% passing threshold with those rules doesn't properly cover that case as 5 voters voting yes out of 10 would pass the proposal. Selecting 50.0001% or or some variation of that also does not work as a very small yes vote which technically makes the majority yes may not reach that threshold.\n\nTo handle these cases we provide both a majority and percent option for all percentages. If majority is selected passing will be determined by `yes > total_votes * 0.5`. If percent is selected passing is determined by `yes >= total_votes * percent`.\n\nIn both of these cases a proposal with only abstain votes must fail. This requires a special case passing logic.",
          "oneOf": [
            {
              "description": "The majority of voters must vote yes for the proposal to pass.",
              "type": "object",
              "required": [
                "majority"
              ],
              "properties": {
                "majority": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "A percentage of voting power >= percent must vote yes for the proposal to pass.",
              "type": "object",
              "required": [
                "percent"
              ],
              "properties": {
                "percent": {
                  "$ref": "#/definitions/Decimal"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "ProposalResponse": {
          "description": "Information about a proposal returned by proposal queries.",
          "type": "object",
          "required": [
            "id",
            "proposal"
          ],
          "properties": {
            "id": {
              "description": "The ID of the proposal being returned.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "proposal": {
              "$ref": "#/definitions/SingleChoiceProposal"
            }
          },
          "additionalProperties": false
        },
        "SingleChoiceProposal": {
          "type": "object",
          "required": [
            "allow_revoting",
            "description",
            "expiration",
            "msgs",
            "proposer",
            "start_height",
            "status",
            "threshold",
            "title",
            "total_power",
            "votes"
          ],
          "properties": {
            "allow_revoting": {
              "description": "Whether or not revoting is enabled. If revoting is enabled, a proposal cannot pass until the voting period has elapsed.",
              "type": "boolean"
            },
            "delegation_module": {
              "description": "The address of the delegation module associated with this proposal (if one existed when the proposal was created).",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "description": {
              "description": "The main body of the proposal text",
              "type": "string"
            },
            "expiration": {
              "description": "The the time at which this proposal will expire and close for additional votes.",
              "allOf": [
                {
                  "$ref": "#/definitions/Expiration"
                }
              ]
            },
            "min_voting_period": {
              "description": "The minimum amount of time this proposal must remain open for voting. The proposal may not pass unless this is expired or None.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Expiration"
                },
                {
                  "type": "null"
                }
              ]
            },
            "msgs": {
              "description": "The messages that will be executed should this proposal pass.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/CosmosMsg_for_Empty"
              }
            },
            "proposer": {
              "description": "The address that created this proposal.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "start_height": {
              "description": "The block height at which this proposal was created. Voting power queries should query for voting power at this block height.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "status": {
              "description": "The proposal status",
              "allOf": [
                {
                  "$ref": "#/definitions/Status"
                }
              ]
            },
            "threshold": {
              "description": "The threshold at which this proposal will pass.",
              "allOf": [
                {
                  "$ref": "#/definitions/Threshold"
                }
              ]
            },
            "title": {
              "description": "The title of the proposal",
              "type": "string"
            },
            "total_power": {
              "description": "The total amount of voting power at the time of this proposal's creation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "veto": {
              "description": "Optional veto configuration. If set to `None`, veto option is disabled. Otherwise contains the configuration for veto flow.",
              "anyOf": [
                {
                  "$ref": "#/definitions/VetoConfig"
                },
                {
                  "type": "null"
                }
              ]
            },
            "votes": {
              "description": "Votes on a particular proposal",
              "allOf": [
                {
                  "$ref": "#/definitions/Votes"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "StakingMsg": {
          "description": "The message types of the staking module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto",
          "oneOf": [
            {
              "description": "This is translated to a [MsgDelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L81-L90). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "delegate"
              ],
              "properties": {
                "delegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "validator"
                  ],
                  "properties": {
                    "amount": {
                      "$ref": "#/definitions/Coin"
                    },
                    "validator": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This is translated to a [MsgUndelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L112-L121). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "undelegate"
              ],
              "properties": {
                "undelegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "validator"
                  ],
                  "properties": {
                    "amount": {
                      "$ref": "#/definitions/Coin"
                    },
                    "validator": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This is translated to a [MsgBeginRedelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L95-L105). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "redelegate"
              ],
              "properties": {
                "redelegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "dst_validator",
                    "src_validator"
                  ],
                  "properties": {
                    "amount": {
                      "$ref": "#/definitions/Coin"
                    },
                    "dst_validator": {
                      "type": "string"
                    },
                    "src_validator": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Status": {
          "oneOf": [
            {
              "description": "The proposal is open for voting.",
              "type": "string",
              "enum": [
                "open"
              ]
            },
            {
              "description": "The proposal has been rejected.",
              "type": "string",
              "enum": [
                "rejected"
              ]
            },
            {
              "description": "The proposal has been passed but has not been executed.",
              "type": "string",
              "enum": [
                "passed"
              ]
            },
            {
              "description": "The proposal has been passed and executed.",
              "type": "string",
              "enum": [
                "executed"
              ]
            },
            {
              "description": "The proposal has failed or expired and has been closed. A proposal deposit refund has been issued if applicable.",
              "type": "string",
              "enum": [
                "closed"
              ]
            },
            {
              "description": "The proposal's execution failed.",
              "type": "string",
              "enum": [
                "execution_failed"
              ]
            },
            {
              "description": "The proposal is timelocked. Only the configured vetoer can execute or veto until the timelock expires.",
              "type": "object",
              "required": [
                "veto_timelock"
              ],
              "properties": {
                "veto_timelock": {
                  "type": "object",
                  "required": [
                    "expiration"
                  ],
                  "properties": {
                    "expiration": {
                      "$ref": "#/definitions/Expiration"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "The proposal has been vetoed.",
              "type": "string",
              "enum": [
                "vetoed"
              ]
            }
          ]
        },
        "Threshold": {
          "description": "The ways a proposal may reach its passing / failing threshold.",
          "oneOf": [
            {
              "description": "Declares a percentage of the total weight that must cast Yes votes in order for a proposal to pass.  See `ThresholdResponse::AbsolutePercentage` in the cw3 spec for details.",
              "type": "object",
              "required": [
                "absolute_percentage"
              ],
              "properties": {
                "absolute_percentage": {
                  "type": "object",
                  "required": [
                    "percentage"
                  ],
                  "properties": {
                    "percentage": {
                      "$ref": "#/definitions/PercentageThreshold"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Declares a `quorum` of the total votes that must participate in the election in order for the vote to be considered at all. See `ThresholdResponse::ThresholdQuorum` in the cw3 spec for details.",
              "type": "object",
              "required": [
                "threshold_quorum"
              ],
              "properties": {
                "threshold_quorum": {
                  "type": "object",
                  "required": [
                    "quorum",
                    "threshold"
                  ],
                  "properties": {
                    "quorum": {
                      "$ref": "#/definitions/PercentageThreshold"
                    },
                    "threshold": {
                      "$ref": "#/definitions/PercentageThreshold"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "An absolute number of votes needed for something to cross the threshold. Useful for multisig style voting.",
              "type": "object",
              "required": [
                "absolute_count"
              ],
              "properties": {
                "absolute_count": {
                  "type": "object",
                  "required": [
                    "threshold"
                  ],
                  "properties": {
                    "threshold": {
                      "$ref": "#/definitions/Uint128"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        },
        "VetoConfig": {
          "type": "object",
          "required": [
            "early_execute",
            "timelock_duration",
            "veto_before_passed",
            "vetoer"
          ],
          "properties": {
            "early_execute": {
              "description": "Whether or not the vetoer can execute a proposal early before the timelock duration has expired",
              "type": "boolean"
            },
            "timelock_duration": {
              "description": "The time duration to lock a proposal for after its expiration to allow the vetoer to veto.",
              "allOf": [
                {
                  "$ref": "#/definitions/Duration"
                }
              ]
            },
            "veto_before_passed": {
              "description": "Whether or not the vetoer can veto a proposal before it passes.",
              "type": "boolean"
            },
            "vetoer": {
              "description": "The address able to veto proposals.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "VoteOption": {
          "type": "string",
          "enum": [
            "yes",
            "no",
            "abstain",
            "no_with_veto"
          ]
        },
        "Votes": {
          "type": "object",
          "required": [
            "abstain",
            "no",
            "yes"
          ],
          "properties": {
            "abstain": {
              "$ref": "#/definitions/Uint128"
            },
            "no": {
              "$ref": "#/definitions/Uint128"
            },
            "yes": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "WasmMsg": {
          "description": "The message types of the wasm module.\n\nSee https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto",
          "oneOf": [
            {
              "description": "Dispatches a call to another contract at a known address (with known ABI).\n\nThis is translated to a [MsgExecuteContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L68-L78). `sender` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "execute"
              ],
              "properties": {
                "execute": {
                  "type": "object",
                  "required": [
                    "contract_addr",
                    "funds",
                    "msg"
                  ],
                  "properties": {
                    "contract_addr": {
                      "type": "string"
                    },
                    "funds": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    },
                    "msg": {
                      "description": "msg is the json-encoded ExecuteMsg struct (as raw Binary)",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Binary"
                        }
                      ]
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Instantiates a new contracts from previously uploaded Wasm code.\n\nThe contract address is non-predictable. But it is guaranteed that when emitting the same Instantiate message multiple times, multiple instances on different addresses will be generated. See also Instantiate2.\n\nThis is translated to a [MsgInstantiateContract](https://github.com/CosmWasm/wasmd/blob/v0.29.2/proto/cosmwasm/wasm/v1/tx.proto#L53-L71). `sender` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "instantiate"
              ],
              "properties": {
                "instantiate": {
                  "type": "object",
                  "required": [
                    "code_id",
                    "funds",
                    "label",
                    "msg"
                  ],
                  "properties": {
                    "admin": {
                      "type": [
                        "string",
                        "null"
                      ]
                    },
                    "code_id": {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "funds": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    },
                    "label": {
                      "description": "A human-readable label for the contract.\n\nValid values should: - not be empty - not be bigger than 128 bytes (or some chain-specific limit) - not start / end with whitespace",
                      "type": "string"
                    },
                    "msg": {
                      "description": "msg is the JSON-encoded InstantiateMsg struct (as raw Binary)",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Binary"
                        }
                      ]
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Instantiates a new contracts from previously uploaded Wasm code using a predictable address derivation algorithm implemented in [`cosmwasm_std::instantiate2_address`].\n\nThis is translated to a [MsgInstantiateContract2](https://github.com/CosmWasm/wasmd/blob/v0.29.2/proto/cosmwasm/wasm/v1/tx.proto#L73-L96). `sender` is automatically filled with the current contract's address. `fix_msg` is automatically set to false.",
              "type": "object",
              "required": [
                "instantiate2"
              ],
              "properties": {
                "instantiate2": {
                  "type": "object",
                  "required": [
                    "code_id",
                    "funds",
                    "label",
                    "msg",
                    "salt"
                  ],
                  "properties": {
                    "admin": {
                      "type": [
                        "string",
                        "null"
                      ]
                    },
                    "code_id": {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "funds": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    },
                    "label": {
                      "description": "A human-readable label for the contract.\n\nValid values should: - not be empty - not be bigger than 128 bytes (or some chain-specific limit) - not start / end with whitespace",
                      "type": "string"
                    },
                    "msg": {
                      "description": "msg is the JSON-encoded InstantiateMsg struct (as raw Binary)",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Binary"
                        }
                      ]
                    },
                    "salt": {
                      "$ref": "#/definitions/Binary"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Migrates a given contracts to use new wasm code. Passes a MigrateMsg to allow us to customize behavior.\n\nOnly the contract admin (as defined in wasmd), if any, is able to make this call.\n\nThis is translated to a [MsgMigrateContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L86-L96). `sender` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "migrate"
              ],
              "properties": {
                "migrate": {
                  "type": "object",
                  "required": [
                    "contract_addr",
                    "msg",
                    "new_code_id"
                  ],
                  "properties": {
                    "contract_addr": {
                      "type": "string"
                    },
                    "msg": {
                      "description": "msg is the json-encoded MigrateMsg struct that will be passed to the new code",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Binary"
                        }
                      ]
                    },
                    "new_code_id": {
                      "description": "the code_id of the new logic to place in the given contract",
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Sets a new admin (for migrate) on the given contract. Fails if this contract is not currently admin of the target contract.",
              "type": "object",
              "required": [
                "update_admin"
              ],
              "properties": {
                "update_admin": {
                  "type": "object",
                  "required": [
                    "admin",
                    "contract_addr"
                  ],
                  "properties": {
                    "admin": {
                      "type": "string"
                    },
                    "contract_addr": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Clears the admin on the given contract, so no more migration possible. Fails if this contract is not currently admin of the target contract.",
              "type": "object",
              "required": [
                "clear_admin"
              ],
              "properties": {
                "clear_admin": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "WeightedVoteOption": {
          "type": "object",
          "required": [
            "option",
            "weight"
          ],
          "properties": {
            "option": {
              "$ref": "#/definitions/VoteOption"
            },
            "weight": {
              "$ref": "#/definitions/Decimal"
            }
          }
        }
      }
    },
    "list_votes": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VoteListResponse",
      "description": "Information about the votes for a proposal.",
      "type": "object",
      "required": [
        "votes"
      ],
      "properties": {
        "votes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/VoteInfo"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Vote": {
          "oneOf": [
            {
              "description": "Marks support for the proposal.",
              "type": "string",
              "enum": [
                "yes"
              ]
            },
            {
              "description": "Marks opposition to the proposal.",
              "type": "string",
              "enum": [
                "no"
              ]
            },
            {
              "description": "Marks participation but does not count towards the ratio of support / opposed.",
              "type": "string",
              "enum": [
                "abstain"
              ]
            }
          ]
        },
        "VoteInfo": {
          "description": "Information about a vote that was cast.",
          "type": "object",
          "required": [
            "power",
            "vote",
            "voter"
          ],
          "properties": {
            "power": {
              "description": "The voting power behind the vote.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "rationale": {
              "description": "Address-specified rationale for the vote.",
              "type": [
                "string",
                "null"
              ]
            },
            "vote": {
              "description": "Position on the vote.",
              "allOf": [
                {
                  "$ref": "#/definitions/Vote"
                }
              ]
            },
            "voter": {
              "description": "The address that voted.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            }
          },
          "additionalProperties": false
        }
      }
    },
    "next_proposal_id": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "uint64",
      "type": "integer",
      "format": "uint64",
      "minimum": 0.0
    },
    "proposal": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ProposalResponse",
      "description": "Information about a proposal returned by proposal queries.",
      "type": "object",
      "required": [
        "id",
        "proposal"
      ],
      "properties": {
        "id": {
          "description": "The ID of the proposal being returned.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "proposal": {
          "$ref": "#/definitions/SingleChoiceProposal"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "BankMsg": {
          "description": "The message types of the bank module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto",
          "oneOf": [
            {
              "description": "Sends native tokens from the contract to the given address.\n\nThis is translated to a [MsgSend](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto#L19-L28). `from_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "send"
              ],
              "properties": {
                "send": {
                  "type": "object",
                  "required": [
                    "amount",
                    "to_address"
                  ],
                  "properties": {
                    "amount": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    },
                    "to_address": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This will burn the given coins from the contract's account. There is no Cosmos SDK message that performs this, but it can be done by calling the bank keeper. Important if a contract controls significant token supply that must be retired.",
              "type": "object",
              "required": [
                "burn"
              ],
              "properties": {
                "burn": {
                  "type": "object",
                  "required": [
                    "amount"
                  ],
                  "properties": {
                    "amount": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Binary": {
          "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "CosmosMsg_for_Empty": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "bank"
              ],
              "properties": {
                "bank": {
                  "$ref": "#/definitions/BankMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "custom"
              ],
              "properties": {
                "custom": {
                  "$ref": "#/definitions/Empty"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "staking"
              ],
              "properties": {
                "staking": {
                  "$ref": "#/definitions/StakingMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "distribution"
              ],
              "properties": {
                "distribution": {
                  "$ref": "#/definitions/DistributionMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "A Stargate message encoded the same way as a protobuf [Any](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/any.proto). This is the same structure as messages in `TxBody` from [ADR-020](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-020-protobuf-transaction-encoding.md)",
              "type": "object",
              "required": [
                "stargate"
              ],
              "properties": {
                "stargate": {
                  "type": "object",
                  "required": [
                    "type_url",
                    "value"
                  ],
                  "properties": {
                    "type_url": {
                      "type": "string"
                    },
                    "value": {
                      "$ref": "#/definitions/Binary"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "ibc"
              ],
              "properties": {
                "ibc": {
                  "$ref": "#/definitions/IbcMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "wasm"
              ],
              "properties": {
                "wasm": {
                  "$ref": "#/definitions/WasmMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "gov"
              ],
              "properties": {
                "gov": {
                  "$ref": "#/definitions/GovMsg"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "DistributionMsg": {
          "description": "The message types of the distribution module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto",
          "oneOf": [
            {
              "description": "This is translated to a [MsgSetWithdrawAddress](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L29-L37). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "set_withdraw_address"
              ],
              "properties": {
                "set_withdraw_address": {
                  "type": "object",
                  "required": [
                    "address"
                  ],
                  "properties": {
                    "address": {
                      "description": "The `withdraw_address`",
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This is translated to a [[MsgWithdrawDelegatorReward](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L42-L50). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "withdraw_delegator_reward"
              ],
              "properties": {
                "withdraw_delegator_reward": {
                  "type": "object",
                  "required": [
                    "validator"
                  ],
                  "properties": {
                    "validator": {
                      "description": "The `validator_address`",
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Duration": {
          "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "height"
              ],
              "properties": {
                "height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Time in seconds",
              "type": "object",
              "required": [
                "time"
              ],
              "properties": {
                "time": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Empty": {
          "description": "An empty struct that serves as a placeholder in different places, such as contracts that don't set a custom message.\n\nIt is designed to be expressable in correct JSON and JSON Schema but contains no meaningful data. Previously we used enums without cases, but those cannot represented as valid JSON Schema (https://github.com/CosmWasm/cosmwasm/issues/451)",
          "type": "object"
        },
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "GovMsg": {
          "description": "This message type allows the contract interact with the [x/gov] module in order to cast votes.\n\n[x/gov]: https://github.com/cosmos/cosmos-sdk/tree/v0.45.12/x/gov\n\n## Examples\n\nCast a simple vote:\n\n``` # use cosmwasm_std::{ #     HexBinary, #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo, #     Response, QueryResponse, # }; # type ExecuteMsg = (); use cosmwasm_std::{GovMsg, VoteOption};\n\n#[entry_point] pub fn execute( deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg, ) -> Result<Response, StdError> { // ... Ok(Response::new().add_message(GovMsg::Vote { proposal_id: 4, vote: VoteOption::Yes, })) } ```\n\nCast a weighted vote:\n\n``` # use cosmwasm_std::{ #     HexBinary, #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo, #     Response, QueryResponse, # }; # type ExecuteMsg = (); # #[cfg(feature = \"cosmwasm_1_2\")] use cosmwasm_std::{Decimal, GovMsg, VoteOption, WeightedVoteOption};\n\n# #[cfg(feature = \"cosmwasm_1_2\")] #[entry_point] pub fn execute( deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg, ) -> Result<Response, StdError> { // ... Ok(Response::new().add_message(GovMsg::VoteWeighted { proposal_id: 4, options: vec![ WeightedVoteOption { option: VoteOption::Yes, weight: Decimal::percent(65), }, WeightedVoteOption { option: VoteOption::Abstain, weight: Decimal::percent(35), }, ], })) } ```",
          "oneOf": [
            {
              "description": "This maps directly to [MsgVote](https://github.com/cosmos/cosmos-sdk/blob/v0.42.5/proto/cosmos/gov/v1beta1/tx.proto#L46-L56) in the Cosmos SDK with voter set to the contract address.",
              "type": "object",
              "required": [
                "vote"
              ],
              "properties": {
                "vote": {
                  "type": "object",
                  "required": [
                    "proposal_id",
                    "vote"
                  ],
                  "properties": {
                    "proposal_id": {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "vote": {
                      "description": "The vote option.\n\nThis should be called \"option\" for consistency with Cosmos SDK. Sorry for that. See <https://github.com/CosmWasm/cosmwasm/issues/1571>.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/VoteOption"
                        }
                      ]
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This maps directly to [MsgVoteWeighted](https://github.com/cosmos/cosmos-sdk/blob/v0.45.8/proto/cosmos/gov/v1beta1/tx.proto#L66-L78) in the Cosmos SDK with voter set to the contract address.",
              "type": "object",
              "required": [
                "vote_weighted"
              ],
              "properties": {
                "vote_weighted": {
                  "type": "object",
                  "required": [
                    "options",
                    "proposal_id"
                  ],
                  "properties": {
                    "options": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/WeightedVoteOption"
                      }
                    },
                    "proposal_id": {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "IbcMsg": {
          "description": "These are messages in the IBC lifecycle. Only usable by IBC-enabled contracts (contracts that directly speak the IBC protocol via 6 entry points)",
          "oneOf": [
            {
              "description": "Sends bank tokens owned by the contract to the given address on another chain. The channel must already be established between the ibctransfer module on this chain and a matching module on the remote chain. We cannot select the port_id, this is whatever the local chain has bound the ibctransfer module to.",
              "type": "object",
              "required": [
                "transfer"
              ],
              "properties": {
                "transfer": {
                  "type": "object",
                  "required": [
                    "amount",
                    "channel_id",
                    "timeout",
                    "to_address"
                  ],
                  "properties": {
                    "amount": {
                      "description": "packet data only supports one coin https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/applications/transfer/v1/transfer.proto#L11-L20",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "channel_id": {
                      "description": "existing channel to send the tokens over",
                      "type": "string"
                    },
                    "timeout": {
                      "description": "when packet times out, measured on remote chain",
                      "allOf": [
                        {
                          "$ref": "#/definitions/IbcTimeout"
                        }
                      ]
                    },
                    "to_address": {
                      "description": "address on the remote chain to receive these tokens",
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Sends an IBC packet with given data over the existing channel. Data should be encoded in a format defined by the channel version, and the module on the other side should know how to parse this.",
              "type": "object",
              "required": [
                "send_packet"
              ],
              "properties": {
                "send_packet": {
                  "type": "object",
                  "required": [
                    "channel_id",
                    "data",
                    "timeout"
                  ],
                  "properties": {
                    "channel_id": {
                      "type": "string"
                    },
                    "data": {
                      "$ref": "#/definitions/Binary"
                    },
                    "timeout": {
                      "description": "when packet times out, measured on remote chain",
                      "allOf": [
                        {
                          "$ref": "#/definitions/IbcTimeout"
                        }
                      ]
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This will close an existing channel that is owned by this contract. Port is auto-assigned to the contract's IBC port",
              "type": "object",
              "required": [
                "close_channel"
              ],
              "properties": {
                "close_channel": {
                  "type": "object",
                  "required": [
                    "channel_id"
                  ],
                  "properties": {
                    "channel_id": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "IbcTimeout": {
          "description": "In IBC each package must set at least one type of timeout: the timestamp or the block height. Using this rather complex enum instead of two timeout fields we ensure that at least one timeout is set.",
          "type": "object",
          "properties": {
            "block": {
              "anyOf": [
                {
                  "$ref": "#/definitions/IbcTimeoutBlock"
                },
                {
                  "type": "null"
                }
              ]
            },
            "timestamp": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        "IbcTimeoutBlock": {
          "description": "IBCTimeoutHeight Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients. Ordering is (revision_number, timeout_height)",
          "type": "object",
          "required": [
            "height",
            "revision"
          ],
          "properties": {
            "height": {
              "description": "block height after which the packet times out. the height within the given revision",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "revision": {
              "description": "the version that the client is currently on (e.g. after resetting the chain this could increment 1 as height drops to 0)",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "PercentageThreshold": {
          "description": "A percentage of voting power that must vote yes for a proposal to pass. An example of why this is needed:\n\nIf a user specifies a 60% passing threshold, and there are 10 voters they likely expect that proposal to pass when there are 6 yes votes. This implies that the condition for passing should be `vote_weights >= total_votes * threshold`.\n\nWith this in mind, how should a user specify that they would like proposals to pass if the majority of voters choose yes? Selecting a 50% passing threshold with those rules doesn't properly cover that case as 5 voters voting yes out of 10 would pass the proposal. Selecting 50.0001% or or some variation of that also does not work as a very small yes vote which technically makes the majority yes may not reach that threshold.\n\nTo handle these cases we provide both a majority and percent option for all percentages. If majority is selected passing will be determined by `yes > total_votes * 0.5`. If percent is selected passing is determined by `yes >= total_votes * percent`.\n\nIn both of these cases a proposal with only abstain votes must fail. This requires a special case passing logic.",
          "oneOf": [
            {
              "description": "The majority of voters must vote yes for the proposal to pass.",
              "type": "object",
              "required": [
                "majority"
              ],
              "properties": {
                "majority": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "A percentage of voting power >= percent must vote yes for the proposal to pass.",
              "type": "object",
              "required": [
                "percent"
              ],
              "properties": {
                "percent": {
                  "$ref": "#/definitions/Decimal"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "SingleChoiceProposal": {
          "type": "object",
          "required": [
            "allow_revoting",
            "description",
            "expiration",
            "msgs",
            "proposer",
            "start_height",
            "status",
            "threshold",
            "title",
            "total_power",
            "votes"
          ],
          "properties": {
            "allow_revoting": {
              "description": "Whether or not revoting is enabled. If revoting is enabled, a proposal cannot pass until the voting period has elapsed.",
              "type": "boolean"
            },
            "delegation_module": {
              "description": "The address of the delegation module associated with this proposal (if one existed when the proposal was created).",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "description": {
              "description": "The main body of the proposal text",
              "type": "string"
            },
            "expiration": {
              "description": "The the time at which this proposal will expire and close for additional votes.",
              "allOf": [
                {
                  "$ref": "#/definitions/Expiration"
                }
              ]
            },
            "min_voting_period": {
              "description": "The minimum amount of time this proposal must remain open for voting. The proposal may not pass unless this is expired or None.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Expiration"
                },
                {
                  "type": "null"
                }
              ]
            },
            "msgs": {
              "description": "The messages that will be executed should this proposal pass.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/CosmosMsg_for_Empty"
              }
            },
            "proposer": {
              "description": "The address that created this proposal.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "start_height": {
              "description": "The block height at which this proposal was created. Voting power queries should query for voting power at this block height.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "status": {
              "description": "The proposal status",
              "allOf": [
                {
                  "$ref": "#/definitions/Status"
                }
              ]
            },
            "threshold": {
              "description": "The threshold at which this proposal will pass.",
              "allOf": [
                {
                  "$ref": "#/definitions/Threshold"
                }
              ]
            },
            "title": {
              "description": "The title of the proposal",
              "type": "string"
            },
            "total_power": {
              "description": "The total amount of voting power at the time of this proposal's creation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "veto": {
              "description": "Optional veto configuration. If set to `None`, veto option is disabled. Otherwise contains the configuration for veto flow.",
              "anyOf": [
                {
                  "$ref": "#/definitions/VetoConfig"
                },
                {
                  "type": "null"
                }
              ]
            },
            "votes": {
              "description": "Votes on a particular proposal",
              "allOf": [
                {
                  "$ref": "#/definitions/Votes"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "StakingMsg": {
          "description": "The message types of the staking module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto",
          "oneOf": [
            {
              "description": "This is translated to a [MsgDelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L81-L90). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "delegate"
              ],
              "properties": {
                "delegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "validator"
                  ],
                  "properties": {
                    "amount": {
                      "$ref": "#/definitions/Coin"
                    },
                    "validator": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This is translated to a [MsgUndelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L112-L121). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "undelegate"
              ],
              "properties": {
                "undelegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "validator"
                  ],
                  "properties": {
                    "amount": {
                      "$ref": "#/definitions/Coin"
                    },
                    "validator": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This is translated to a [MsgBeginRedelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L95-L105). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "redelegate"
              ],
              "properties": {
                "redelegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "dst_validator",
                    "src_validator"
                  ],
                  "properties": {
                    "amount": {
                      "$ref": "#/definitions/Coin"
                    },
                    "dst_validator": {
                      "type": "string"
                    },
                    "src_validator": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Status": {
          "oneOf": [
            {
              "description": "The proposal is open for voting.",
              "type": "string",
              "enum": [
                "open"
              ]
            },
            {
              "description": "The proposal has been rejected.",
              "type": "string",
              "enum": [
                "rejected"
              ]
            },
            {
              "description": "The proposal has been passed but has not been executed.",
              "type": "string",
              "enum": [
                "passed"
              ]
            },
            {
              "description": "The proposal has been passed and executed.",
              "type": "string",
              "enum": [
                "executed"
              ]
            },
            {
              "description": "The proposal has failed or expired and has been closed. A proposal deposit refund has been issued if applicable.",
              "type": "string",
              "enum": [
                "closed"
              ]
            },
            {
              "description": "The proposal's execution failed.",
              "type": "string",
              "enum": [
                "execution_failed"
              ]
            },
            {
              "description": "The proposal is timelocked. Only the configured vetoer can execute or veto until the timelock expires.",
              "type": "object",
              "required": [
                "veto_timelock"
              ],
              "properties": {
                "veto_timelock": {
                  "type": "object",
                  "required": [
                    "expiration"
                  ],
                  "properties": {
                    "expiration": {
                      "$ref": "#/definitions/Expiration"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "The proposal has been vetoed.",
              "type": "string",
              "enum": [
                "vetoed"
              ]
            }
          ]
        },
        "Threshold": {
          "description": "The ways a proposal may reach its passing / failing threshold.",
          "oneOf": [
            {
              "description": "Declares a percentage of the total weight that must cast Yes votes in order for a proposal to pass.  See `ThresholdResponse::AbsolutePercentage` in the cw3 spec for details.",
              "type": "object",
              "required": [
                "absolute_percentage"
              ],
              "properties": {
                "absolute_percentage": {
                  "type": "object",
                  "required": [
                    "percentage"
                  ],
                  "properties": {
                    "percentage": {
                      "$ref": "#/definitions/PercentageThreshold"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Declares a `quorum` of the total votes that must participate in the election in order for the vote to be considered at all. See `ThresholdResponse::ThresholdQuorum` in the cw3 spec for details.",
              "type": "object",
              "required": [
                "threshold_quorum"
              ],
              "properties": {
                "threshold_quorum": {
                  "type": "object",
                  "required": [
                    "quorum",
                    "threshold"
                  ],
                  "properties": {
                    "quorum": {
                      "$ref": "#/definitions/PercentageThreshold"
                    },
                    "threshold": {
                      "$ref": "#/definitions/PercentageThreshold"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "An absolute number of votes needed for something to cross the threshold. Useful for multisig style voting.",
              "type": "object",
              "required": [
                "absolute_count"
              ],
              "properties": {
                "absolute_count": {
                  "type": "object",
                  "required": [
                    "threshold"
                  ],
                  "properties": {
                    "threshold": {
                      "$ref": "#/definitions/Uint128"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        },
        "VetoConfig": {
          "type": "object",
          "required": [
            "early_execute",
            "timelock_duration",
            "veto_before_passed",
            "vetoer"
          ],
          "properties": {
            "early_execute": {
              "description": "Whether or not the vetoer can execute a proposal early before the timelock duration has expired",
              "type": "boolean"
            },
            "timelock_duration": {
              "description": "The time duration to lock a proposal for after its expiration to allow the vetoer to veto.",
              "allOf": [
                {
                  "$ref": "#/definitions/Duration"
                }
              ]
            },
            "veto_before_passed": {
              "description": "Whether or not the vetoer can veto a proposal before it passes.",
              "type": "boolean"
            },
            "vetoer": {
              "description": "The address able to veto proposals.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "VoteOption": {
          "type": "string",
          "enum": [
            "yes",
            "no",
            "abstain",
            "no_with_veto"
          ]
        },
        "Votes": {
          "type": "object",
          "required": [
            "abstain",
            "no",
            "yes"
          ],
          "properties": {
            "abstain": {
              "$ref": "#/definitions/Uint128"
            },
            "no": {
              "$ref": "#/definitions/Uint128"
            },
            "yes": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "WasmMsg": {
          "description": "The message types of the wasm module.\n\nSee https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto",
          "oneOf": [
            {
              "description": "Dispatches a call to another contract at a known address (with known ABI).\n\nThis is translated to a [MsgExecuteContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L68-L78). `sender` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "execute"
              ],
              "properties": {
                "execute": {
                  "type": "object",
                  "required": [
                    "contract_addr",
                    "funds",
                    "msg"
                  ],
                  "properties": {
                    "contract_addr": {
                      "type": "string"
                    },
                    "funds": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    },
                    "msg": {
                      "description": "msg is the json-encoded ExecuteMsg struct (as raw Binary)",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Binary"
                        }
                      ]
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Instantiates a new contracts from previously uploaded Wasm code.\n\nThe contract address is non-predictable. But it is guaranteed that when emitting the same Instantiate message multiple times, multiple instances on different addresses will be generated. See also Instantiate2.\n\nThis is translated to a [MsgInstantiateContract](https://github.com/CosmWasm/wasmd/blob/v0.29.2/proto/cosmwasm/wasm/v1/tx.proto#L53-L71). `sender` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "instantiate"
              ],
              "properties": {
                "instantiate": {
                  "type": "object",
                  "required": [
                    "code_id",
                    "funds",
                    "label",
                    "msg"
                  ],
                  "properties": {
                    "admin": {
                      "type": [
                        "string",
                        "null"
                      ]
                    },
                    "code_id": {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "funds": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    },
                    "label": {
                      "description": "A human-readable label for the contract.\n\nValid values should: - not be empty - not be bigger than 128 bytes (or some chain-specific limit) - not start / end with whitespace",
                      "type": "string"
                    },
                    "msg": {
                      "description": "msg is the JSON-encoded InstantiateMsg struct (as raw Binary)",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Binary"
                        }
                      ]
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Instantiates a new contracts from previously uploaded Wasm code using a predictable address derivation algorithm implemented in [`cosmwasm_std::instantiate2_address`].\n\nThis is translated to a [MsgInstantiateContract2](https://github.com/CosmWasm/wasmd/blob/v0.29.2/proto/cosmwasm/wasm/v1/tx.proto#L73-L96). `sender` is automatically filled with the current contract's address. `fix_msg` is automatically set to false.",
              "type": "object",
              "required": [
                "instantiate2"
              ],
              "properties": {
                "instantiate2": {
                  "type": "object",
                  "required": [
                    "code_id",
                    "funds",
                    "label",
                    "msg",
                    "salt"
                  ],
                  "properties": {
                    "admin": {
                      "type": [
                        "string",
                        "null"
                      ]
                    },
                    "code_id": {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "funds": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    },
                    "label": {
                      "description": "A human-readable label for the contract.\n\nValid values should: - not be empty - not be bigger than 128 bytes (or some chain-specific limit) - not start / end with whitespace",
                      "type": "string"
                    },
                    "msg": {
                      "description": "msg is the JSON-encoded InstantiateMsg struct (as raw Binary)",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Binary"
                        }
                      ]
                    },
                    "salt": {
                      "$ref": "#/definitions/Binary"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Migrates a given contracts to use new wasm code. Passes a MigrateMsg to allow us to customize behavior.\n\nOnly the contract admin (as defined in wasmd), if any, is able to make this call.\n\nThis is translated to a [MsgMigrateContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L86-L96). `sender` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "migrate"
              ],
              "properties": {
                "migrate": {
                  "type": "object",
                  "required": [
                    "contract_addr",
                    "msg",
                    "new_code_id"
                  ],
                  "properties": {
                    "contract_addr": {
                      "type": "string"
                    },
                    "msg": {
                      "description": "msg is the json-encoded MigrateMsg struct that will be passed to the new code",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Binary"
                        }
                      ]
                    },
                    "new_code_id": {
                      "description": "the code_id of the new logic to place in the given contract",
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Sets a new admin (for migrate) on the given contract. Fails if this contract is not currently admin of the target contract.",
              "type": "object",
              "required": [
                "update_admin"
              ],
              "properties": {
                "update_admin": {
                  "type": "object",
                  "required": [
                    "admin",
                    "contract_addr"
                  ],
                  "properties": {
                    "admin": {
                      "type": "string"
                    },
                    "contract_addr": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Clears the admin on the given contract, so no more migration possible. Fails if this contract is not currently admin of the target contract.",
              "type": "object",
              "required": [
                "clear_admin"
              ],
              "properties": {
                "clear_admin": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "WeightedVoteOption": {
          "type": "object",
          "required": [
            "option",
            "weight"
          ],
          "properties": {
            "option": {
              "$ref": "#/definitions/VoteOption"
            },
            "weight": {
              "$ref": "#/definitions/Decimal"
            }
          }
        }
      }
    },
    "proposal_count": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "uint64",
      "type": "integer",
      "format": "uint64",
      "minimum": 0.0
    },
    "proposal_creation_policy": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ProposalCreationPolicy",
      "description": "The policy configured in a proposal module that determines whether or not a pre-propose module is in use. If so, only the module can create new proposals. Otherwise, there is no restriction on proposal creation.",
      "oneOf": [
        {
          "description": "Anyone may create a proposal, free of charge.",
          "type": "object",
          "required": [
            "anyone"
          ],
          "properties": {
            "anyone": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Only ADDR may create proposals. It is expected that ADDR is a pre-propose module, though we only require that it is a valid address.",
          "type": "object",
          "required": [
            "module"
          ],
          "properties": {
            "module": {
              "type": "object",
              "required": [
                "addr"
              ],
              "properties": {
                "addr": {
                  "$ref": "#/definitions/Addr"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "proposal_hooks": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "HooksResponse",
      "type": "object",
      "required": [
        "hooks"
      ],
      "properties": {
        "hooks": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "reverse_proposals": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ProposalListResponse",
      "description": "A list of proposals returned by `ListProposals` and `ReverseProposals`.",
      "type": "object",
      "required": [
        "proposals"
      ],
      "properties": {
        "proposals": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ProposalResponse"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "BankMsg": {
          "description": "The message types of the bank module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto",
          "oneOf": [
            {
              "description": "Sends native tokens from the contract to the given address.\n\nThis is translated to a [MsgSend](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto#L19-L28). `from_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "send"
              ],
              "properties": {
                "send": {
                  "type": "object",
                  "required": [
                    "amount",
                    "to_address"
                  ],
                  "properties": {
                    "amount": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    },
                    "to_address": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This will burn the given coins from the contract's account. There is no Cosmos SDK message that performs this, but it can be done by calling the bank keeper. Important if a contract controls significant token supply that must be retired.",
              "type": "object",
              "required": [
                "burn"
              ],
              "properties": {
                "burn": {
                  "type": "object",
                  "required": [
                    "amount"
                  ],
                  "properties": {
                    "amount": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Binary": {
          "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "CosmosMsg_for_Empty": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "bank"
              ],
              "properties": {
                "bank": {
                  "$ref": "#/definitions/BankMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "custom"
              ],
              "properties": {
                "custom": {
                  "$ref": "#/definitions/Empty"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "staking"
              ],
              "properties": {
                "staking": {
                  "$ref": "#/definitions/StakingMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "distribution"
              ],
              "properties": {
                "distribution": {
                  "$ref": "#/definitions/DistributionMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "A Stargate message encoded the same way as a protobuf [Any](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/any.proto). This is the same structure as messages in `TxBody` from [ADR-020](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-020-protobuf-transaction-encoding.md)",
              "type": "object",
              "required": [
                "stargate"
              ],
              "properties": {
                "stargate": {
                  "type": "object",
                  "required": [
                    "type_url",
                    "value"
                  ],
                  "properties": {
                    "type_url": {
                      "type": "string"
                    },
                    "value": {
                      "$ref": "#/definitions/Binary"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "ibc"
              ],
              "properties": {
                "ibc": {
                  "$ref": "#/definitions/IbcMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "wasm"
              ],
              "properties": {
                "wasm": {
                  "$ref": "#/definitions/WasmMsg"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "gov"
              ],
              "properties": {
                "gov": {
                  "$ref": "#/definitions/GovMsg"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "DistributionMsg": {
          "description": "The message types of the distribution module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto",
          "oneOf": [
            {
              "description": "This is translated to a [MsgSetWithdrawAddress](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L29-L37). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "set_withdraw_address"
              ],
              "properties": {
                "set_withdraw_address": {
                  "type": "object",
                  "required": [
                    "address"
                  ],
                  "properties": {
                    "address": {
                      "description": "The `withdraw_address`",
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This is translated to a [[MsgWithdrawDelegatorReward](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L42-L50). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "withdraw_delegator_reward"
              ],
              "properties": {
                "withdraw_delegator_reward": {
                  "type": "object",
                  "required": [
                    "validator"
                  ],
                  "properties": {
                    "validator": {
                      "description": "The `validator_address`",
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Duration": {
          "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "height"
              ],
              "properties": {
                "height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Time in seconds",
              "type": "object",
              "required": [
                "time"
              ],
              "properties": {
                "time": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Empty": {
          "description": "An empty struct that serves as a placeholder in different places, such as contracts that don't set a custom message.\n\nIt is designed to be expressable in correct JSON and JSON Schema but contains no meaningful data. Previously we used enums without cases, but those cannot represented as valid JSON Schema (https://github.com/CosmWasm/cosmwasm/issues/451)",
          "type": "object"
        },
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "GovMsg": {
          "description": "This message type allows the contract interact with the [x/gov] module in order to cast votes.\n\n[x/gov]: https://github.com/cosmos/cosmos-sdk/tree/v0.45.12/x/gov\n\n## Examples\n\nCast a simple vote:\n\n``` # use cosmwasm_std::{ #     HexBinary, #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo, #     Response, QueryResponse, # }; # type ExecuteMsg = (); use cosmwasm_std::{GovMsg, VoteOption};\n\n#[entry_point] pub fn execute( deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg, ) -> Result<Response, StdError> { // ... Ok(Response::new().add_message(GovMsg::Vote { proposal_id: 4, vote: VoteOption::Yes, })) } ```\n\nCast a weighted vote:\n\n``` # use cosmwasm_std::{ #     HexBinary, #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo, #     Response, QueryResponse, # }; # type ExecuteMsg = (); # #[cfg(feature = \"cosmwasm_1_2\")] use cosmwasm_std::{Decimal, GovMsg, VoteOption, WeightedVoteOption};\n\n# #[cfg(feature = \"cosmwasm_1_2\")] #[entry_point] pub fn execute( deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg, ) -> Result<Response, StdError> { // ... Ok(Response::new().add_message(GovMsg::VoteWeighted { proposal_id: 4, options: vec![ WeightedVoteOption { option: VoteOption::Yes, weight: Decimal::percent(65), }, WeightedVoteOption { option: VoteOption::Abstain, weight: Decimal::percent(35), }, ], })) } ```",
          "oneOf": [
            {
              "description": "This maps directly to [MsgVote](https://github.com/cosmos/cosmos-sdk/blob/v0.42.5/proto/cosmos/gov/v1beta1/tx.proto#L46-L56) in the Cosmos SDK with voter set to the contract address.",
              "type": "object",
              "required": [
                "vote"
              ],
              "properties": {
                "vote": {
                  "type": "object",
                  "required": [
                    "proposal_id",
                    "vote"
                  ],
                  "properties": {
                    "proposal_id": {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "vote": {
                      "description": "The vote option.\n\nThis should be called \"option\" for consistency with Cosmos SDK. Sorry for that. See <https://github.com/CosmWasm/cosmwasm/issues/1571>.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/VoteOption"
                        }
                      ]
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This maps directly to [MsgVoteWeighted](https://github.com/cosmos/cosmos-sdk/blob/v0.45.8/proto/cosmos/gov/v1beta1/tx.proto#L66-L78) in the Cosmos SDK with voter set to the contract address.",
              "type": "object",
              "required": [
                "vote_weighted"
              ],
              "properties": {
                "vote_weighted": {
                  "type": "object",
                  "required": [
                    "options",
                    "proposal_id"
                  ],
                  "properties": {
                    "options": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/WeightedVoteOption"
                      }
                    },
                    "proposal_id": {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "IbcMsg": {
          "description": "These are messages in the IBC lifecycle. Only usable by IBC-enabled contracts (contracts that directly speak the IBC protocol via 6 entry points)",
          "oneOf": [
            {
              "description": "Sends bank tokens owned by the contract to the given address on another chain. The channel must already be established between the ibctransfer module on this chain and a matching module on the remote chain. We cannot select the port_id, this is whatever the local chain has bound the ibctransfer module to.",
              "type": "object",
              "required": [
                "transfer"
              ],
              "properties": {
                "transfer": {
                  "type": "object",
                  "required": [
                    "amount",
                    "channel_id",
                    "timeout",
                    "to_address"
                  ],
                  "properties": {
                    "amount": {
                      "description": "packet data only supports one coin https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/applications/transfer/v1/transfer.proto#L11-L20",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "channel_id": {
                      "description": "existing channel to send the tokens over",
                      "type": "string"
                    },
                    "timeout": {
                      "description": "when packet times out, measured on remote chain",
                      "allOf": [
                        {
                          "$ref": "#/definitions/IbcTimeout"
                        }
                      ]
                    },
                    "to_address": {
                      "description": "address on the remote chain to receive these tokens",
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Sends an IBC packet with given data over the existing channel. Data should be encoded in a format defined by the channel version, and the module on the other side should know how to parse this.",
              "type": "object",
              "required": [
                "send_packet"
              ],
              "properties": {
                "send_packet": {
                  "type": "object",
                  "required": [
                    "channel_id",
                    "data",
                    "timeout"
                  ],
                  "properties": {
                    "channel_id": {
                      "type": "string"
                    },
                    "data": {
                      "$ref": "#/definitions/Binary"
                    },
                    "timeout": {
                      "description": "when packet times out, measured on remote chain",
                      "allOf": [
                        {
                          "$ref": "#/definitions/IbcTimeout"
                        }
                      ]
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This will close an existing channel that is owned by this contract. Port is auto-assigned to the contract's IBC port",
              "type": "object",
              "required": [
                "close_channel"
              ],
              "properties": {
                "close_channel": {
                  "type": "object",
                  "required": [
                    "channel_id"
                  ],
                  "properties": {
                    "channel_id": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "IbcTimeout": {
          "description": "In IBC each package must set at least one type of timeout: the timestamp or the block height. Using this rather complex enum instead of two timeout fields we ensure that at least one timeout is set.",
          "type": "object",
          "properties": {
            "block": {
              "anyOf": [
                {
                  "$ref": "#/definitions/IbcTimeoutBlock"
                },
                {
                  "type": "null"
                }
              ]
            },
            "timestamp": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        "IbcTimeoutBlock": {
          "description": "IBCTimeoutHeight Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients. Ordering is (revision_number, timeout_height)",
          "type": "object",
          "required": [
            "height",
            "revision"
          ],
          "properties": {
            "height": {
              "description": "block height after which the packet times out. the height within the given revision",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "revision": {
              "description": "the version that the client is currently on (e.g. after resetting the chain this could increment 1 as height drops to 0)",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "PercentageThreshold": {
          "description": "A percentage of voting power that must vote yes for a proposal to pass. An example of why this is needed:\n\nIf a user specifies a 60% passing threshold, and there are 10 voters they likely expect that proposal to pass when there are 6 yes votes. This implies that the condition for passing should be `vote_weights >= total_votes * threshold`.\n\nWith this in mind, how should a user specify that they would like proposals to pass if the majority of voters choose yes? Selecting a 50% passing threshold with those rules doesn't properly cover that case as 5 voters voting yes out of 10 would pass the proposal. Selecting 50.0001% or or some variation of that also does not work as a very small yes vote which technically makes the majority yes may not reach that threshold.\n\nTo handle these cases we provide both a majority and percent option for all percentages. If majority is selected passing will be determined by `yes > total_votes * 0.5`. If percent is selected passing is determined by `yes >= total_votes * percent`.\n\nIn both of these cases a proposal with only abstain votes must fail. This requires a special case passing logic.",
          "oneOf": [
            {
              "description": "The majority of voters must vote yes for the proposal to pass.",
              "type": "object",
              "required": [
                "majority"
              ],
              "properties": {
                "majority": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "A percentage of voting power >= percent must vote yes for the proposal to pass.",
              "type": "object",
              "required": [
                "percent"
              ],
              "properties": {
                "percent": {
                  "$ref": "#/definitions/Decimal"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "ProposalResponse": {
          "description": "Information about a proposal returned by proposal queries.",
          "type": "object",
          "required": [
            "id",
            "proposal"
          ],
          "properties": {
            "id": {
              "description": "The ID of the proposal being returned.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "proposal": {
              "$ref": "#/definitions/SingleChoiceProposal"
            }
          },
          "additionalProperties": false
        },
        "SingleChoiceProposal": {
          "type": "object",
          "required": [
            "allow_revoting",
            "description",
            "expiration",
            "msgs",
            "proposer",
            "start_height",
            "status",
            "threshold",
            "title",
            "total_power",
            "votes"
          ],
          "properties": {
            "allow_revoting": {
              "description": "Whether or not revoting is enabled. If revoting is enabled, a proposal cannot pass until the voting period has elapsed.",
              "type": "boolean"
            },
            "delegation_module": {
              "description": "The address of the delegation module associated with this proposal (if one existed when the proposal was created).",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "description": {
              "description": "The main body of the proposal text",
              "type": "string"
            },
            "expiration": {
              "description": "The the time at which this proposal will expire and close for additional votes.",
              "allOf": [
                {
                  "$ref": "#/definitions/Expiration"
                }
              ]
            },
            "min_voting_period": {
              "description": "The minimum amount of time this proposal must remain open for voting. The proposal may not pass unless this is expired or None.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Expiration"
                },
                {
                  "type": "null"
                }
              ]
            },
            "msgs": {
              "description": "The messages that will be executed should this proposal pass.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/CosmosMsg_for_Empty"
              }
            },
            "proposer": {
              "description": "The address that created this proposal.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "start_height": {
              "description": "The block height at which this proposal was created. Voting power queries should query for voting power at this block height.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "status": {
              "description": "The proposal status",
              "allOf": [
                {
                  "$ref": "#/definitions/Status"
                }
              ]
            },
            "threshold": {
              "description": "The threshold at which this proposal will pass.",
              "allOf": [
                {
                  "$ref": "#/definitions/Threshold"
                }
              ]
            },
            "title": {
              "description": "The title of the proposal",
              "type": "string"
            },
            "total_power": {
              "description": "The total amount of voting power at the time of this proposal's creation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "veto": {
              "description": "Optional veto configuration. If set to `None`, veto option is disabled. Otherwise contains the configuration for veto flow.",
              "anyOf": [
                {
                  "$ref": "#/definitions/VetoConfig"
                },
                {
                  "type": "null"
                }
              ]
            },
            "votes": {
              "description": "Votes on a particular proposal",
              "allOf": [
                {
                  "$ref": "#/definitions/Votes"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "StakingMsg": {
          "description": "The message types of the staking module.\n\nSee https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto",
          "oneOf": [
            {
              "description": "This is translated to a [MsgDelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L81-L90). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "delegate"
              ],
              "properties": {
                "delegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "validator"
                  ],
                  "properties": {
                    "amount": {
                      "$ref": "#/definitions/Coin"
                    },
                    "validator": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This is translated to a [MsgUndelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L112-L121). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "undelegate"
              ],
              "properties": {
                "undelegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "validator"
                  ],
                  "properties": {
                    "amount": {
                      "$ref": "#/definitions/Coin"
                    },
                    "validator": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "This is translated to a [MsgBeginRedelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L95-L105). `delegator_address` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "redelegate"
              ],
              "properties": {
                "redelegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "dst_validator",
                    "src_validator"
                  ],
                  "properties": {
                    "amount": {
                      "$ref": "#/definitions/Coin"
                    },
                    "dst_validator": {
                      "type": "string"
                    },
                    "src_validator": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Status": {
          "oneOf": [
            {
              "description": "The proposal is open for voting.",
              "type": "string",
              "enum": [
                "open"
              ]
            },
            {
              "description": "The proposal has been rejected.",
              "type": "string",
              "enum": [
                "rejected"
              ]
            },
            {
              "description": "The proposal has been passed but has not been executed.",
              "type": "string",
              "enum": [
                "passed"
              ]
            },
            {
              "description": "The proposal has been passed and executed.",
              "type": "string",
              "enum": [
                "executed"
              ]
            },
            {
              "description": "The proposal has failed or expired and has been closed. A proposal deposit refund has been issued if applicable.",
              "type": "string",
              "enum": [
                "closed"
              ]
            },
            {
              "description": "The proposal's execution failed.",
              "type": "string",
              "enum": [
                "execution_failed"
              ]
            },
            {
              "description": "The proposal is timelocked. Only the configured vetoer can execute or veto until the timelock expires.",
              "type": "object",
              "required": [
                "veto_timelock"
              ],
              "properties": {
                "veto_timelock": {
                  "type": "object",
                  "required": [
                    "expiration"
                  ],
                  "properties": {
                    "expiration": {
                      "$ref": "#/definitions/Expiration"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "The proposal has been vetoed.",
              "type": "string",
              "enum": [
                "vetoed"
              ]
            }
          ]
        },
        "Threshold": {
          "description": "The ways a proposal may reach its passing / failing threshold.",
          "oneOf": [
            {
              "description": "Declares a percentage of the total weight that must cast Yes votes in order for a proposal to pass.  See `ThresholdResponse::AbsolutePercentage` in the cw3 spec for details.",
              "type": "object",
              "required": [
                "absolute_percentage"
              ],
              "properties": {
                "absolute_percentage": {
                  "type": "object",
                  "required": [
                    "percentage"
                  ],
                  "properties": {
                    "percentage": {
                      "$ref": "#/definitions/PercentageThreshold"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Declares a `quorum` of the total votes that must participate in the election in order for the vote to be considered at all. See `ThresholdResponse::ThresholdQuorum` in the cw3 spec for details.",
              "type": "object",
              "required": [
                "threshold_quorum"
              ],
              "properties": {
                "threshold_quorum": {
                  "type": "object",
                  "required": [
                    "quorum",
                    "threshold"
                  ],
                  "properties": {
                    "quorum": {
                      "$ref": "#/definitions/PercentageThreshold"
                    },
                    "threshold": {
                      "$ref": "#/definitions/PercentageThreshold"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "An absolute number of votes needed for something to cross the threshold. Useful for multisig style voting.",
              "type": "object",
              "required": [
                "absolute_count"
              ],
              "properties": {
                "absolute_count": {
                  "type": "object",
                  "required": [
                    "threshold"
                  ],
                  "properties": {
                    "threshold": {
                      "$ref": "#/definitions/Uint128"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        },
        "VetoConfig": {
          "type": "object",
          "required": [
            "early_execute",
            "timelock_duration",
            "veto_before_passed",
            "vetoer"
          ],
          "properties": {
            "early_execute": {
              "description": "Whether or not the vetoer can execute a proposal early before the timelock duration has expired",
              "type": "boolean"
            },
            "timelock_duration": {
              "description": "The time duration to lock a proposal for after its expiration to allow the vetoer to veto.",
              "allOf": [
                {
                  "$ref": "#/definitions/Duration"
                }
              ]
            },
            "veto_before_passed": {
              "description": "Whether or not the vetoer can veto a proposal before it passes.",
              "type": "boolean"
            },
            "vetoer": {
              "description": "The address able to veto proposals.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "VoteOption": {
          "type": "string",
          "enum": [
            "yes",
            "no",
            "abstain",
            "no_with_veto"
          ]
        },
        "Votes": {
          "type": "object",
          "required": [
            "abstain",
            "no",
            "yes"
          ],
          "properties": {
            "abstain": {
              "$ref": "#/definitions/Uint128"
            },
            "no": {
              "$ref": "#/definitions/Uint128"
            },
            "yes": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "WasmMsg": {
          "description": "The message types of the wasm module.\n\nSee https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto",
          "oneOf": [
            {
              "description": "Dispatches a call to another contract at a known address (with known ABI).\n\nThis is translated to a [MsgExecuteContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L68-L78). `sender` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "execute"
              ],
              "properties": {
                "execute": {
                  "type": "object",
                  "required": [
                    "contract_addr",
                    "funds",
                    "msg"
                  ],
                  "properties": {
                    "contract_addr": {
                      "type": "string"
                    },
                    "funds": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    },
                    "msg": {
                      "description": "msg is the json-encoded ExecuteMsg struct (as raw Binary)",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Binary"
                        }
                      ]
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Instantiates a new contracts from previously uploaded Wasm code.\n\nThe contract address is non-predictable. But it is guaranteed that when emitting the same Instantiate message multiple times, multiple instances on different addresses will be generated. See also Instantiate2.\n\nThis is translated to a [MsgInstantiateContract](https://github.com/CosmWasm/wasmd/blob/v0.29.2/proto/cosmwasm/wasm/v1/tx.proto#L53-L71). `sender` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "instantiate"
              ],
              "properties": {
                "instantiate": {
                  "type": "object",
                  "required": [
                    "code_id",
                    "funds",
                    "label",
                    "msg"
                  ],
                  "properties": {
                    "admin": {
                      "type": [
                        "string",
                        "null"
                      ]
                    },
                    "code_id": {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "funds": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    },
                    "label": {
                      "description": "A human-readable label for the contract.\n\nValid values should: - not be empty - not be bigger than 128 bytes (or some chain-specific limit) - not start / end with whitespace",
                      "type": "string"
                    },
                    "msg": {
                      "description": "msg is the JSON-encoded InstantiateMsg struct (as raw Binary)",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Binary"
                        }
                      ]
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Instantiates a new contracts from previously uploaded Wasm code using a predictable address derivation algorithm implemented in [`cosmwasm_std::instantiate2_address`].\n\nThis is translated to a [MsgInstantiateContract2](https://github.com/CosmWasm/wasmd/blob/v0.29.2/proto/cosmwasm/wasm/v1/tx.proto#L73-L96). `sender` is automatically filled with the current contract's address. `fix_msg` is automatically set to false.",
              "type": "object",
              "required": [
                "instantiate2"
              ],
              "properties": {
                "instantiate2": {
                  "type": "object",
                  "required": [
                    "code_id",
                    "funds",
                    "label",
                    "msg",
                    "salt"
                  ],
                  "properties": {
                    "admin": {
                      "type": [
                        "string",
                        "null"
                      ]
                    },
                    "code_id": {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "funds": {
                      "type": "array",
                      "items": {
                        "$ref": "#/definitions/Coin"
                      }
                    },
                    "label": {
                      "description": "A human-readable label for the contract.\n\nValid values should: - not be empty - not be bigger than 128 bytes (or some chain-specific limit) - not start / end with whitespace",
                      "type": "string"
                    },
                    "msg": {
                      "description": "msg is the JSON-encoded InstantiateMsg struct (as raw Binary)",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Binary"
                        }
                      ]
                    },
                    "salt": {
                      "$ref": "#/definitions/Binary"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Migrates a given contracts to use new wasm code. Passes a MigrateMsg to allow us to customize behavior.\n\nOnly the contract admin (as defined in wasmd), if any, is able to make this call.\n\nThis is translated to a [MsgMigrateContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L86-L96). `sender` is automatically filled with the current contract's address.",
              "type": "object",
              "required": [
                "migrate"
              ],
              "properties": {
                "migrate": {
                  "type": "object",
                  "required": [
                    "contract_addr",
                    "msg",
                    "new_code_id"
                  ],
                  "properties": {
                    "contract_addr": {
                      "type": "string"
                    },
                    "msg": {
                      "description": "msg is the json-encoded MigrateMsg struct that will be passed to the new code",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Binary"
                        }
                      ]
                    },
                    "new_code_id": {
                      "description": "the code_id of the new logic to place in the given contract",
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Sets a new admin (for migrate) on the given contract. Fails if this contract is not currently admin of the target contract.",
              "type": "object",
              "required": [
                "update_admin"
              ],
              "properties": {
                "update_admin": {
                  "type": "object",
                  "required": [
                    "admin",
                    "contract_addr"
                  ],
                  "properties": {
                    "admin": {
                      "type": "string"
                    },
                    "contract_addr": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Clears the admin on the given contract, so no more migration possible. Fails if this contract is not currently admin of the target contract.",
              "type": "object",
              "required": [
                "clear_admin"
              ],
              "properties": {
                "clear_admin": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "type": "string"
                    }
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "WeightedVoteOption": {
          "type": "object",
          "required": [
            "option",
            "weight"
          ],
          "properties": {
            "option": {
              "$ref": "#/definitions/VoteOption"
            },
            "weight": {
              "$ref": "#/definitions/Decimal"
            }
          }
        }
      }
    },
    "vote_hooks": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "HooksResponse",
      "type": "object",
      "required": [
        "hooks"
      ],
      "properties": {
        "hooks": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    }
  }
}
